!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], e)
: (t.THREEDebugRenderTarget = e(t.THREE));
})(this, function(t) {
"use strict";
function e(t, e) {
return t((e = {exports: {}}), e.exports), e.exports;
}
t = t && t.hasOwnProperty("default") ? t.default : t;
var a = e(function(t, e) {
var a =
"undefined" != typeof Uint8Array &&
"undefined" != typeof Uint16Array &&
"undefined" != typeof Int32Array;
function r(t, e) {
return Object.prototype.hasOwnProperty.call(t, e);
}
(e.assign = function(t) {
for (var e = Array.prototype.slice.call(arguments, 1); e.length; ) {
var a = e.shift();
if (a) {
if ("object" != typeof a) throw new TypeError(a + "must be non-object");
for (var n in a) r(a, n) && (t[n] = a[n]);
}
}
return t;
}),
(e.shrinkBuf = function(t, e) {
return t.length === e ? t : t.subarray ? t.subarray(0, e) : ((t.length = e), t);
});
var n = {
arraySet: function(t, e, a, r, n) {
if (e.subarray && t.subarray) t.set(e.subarray(a, a + r), n);
else for (var i = 0; i < r; i++) t[n + i] = e[a + i];
},
flattenChunks: function(t) {
var e, a, r, n, i, s;
for (r = 0, e = 0, a = t.length; e < a; e++) r += t[e].length;
for (s = new Uint8Array(r), n = 0, e = 0, a = t.length; e < a; e++)
(i = t[e]), s.set(i, n), (n += i.length);
return s;
}
},
i = {
arraySet: function(t, e, a, r, n) {
for (var i = 0; i < r; i++) t[n + i] = e[a + i];
},
flattenChunks: function(t) {
return [].concat.apply([], t);
}
};
(e.setTyped = function(t) {
t
? ((e.Buf8 = Uint8Array),
  (e.Buf16 = Uint16Array),
  (e.Buf32 = Int32Array),
  e.assign(e, n))
: ((e.Buf8 = Array), (e.Buf16 = Array), (e.Buf32 = Array), e.assign(e, i));
}),
e.setTyped(a);
}),
r = (a.assign, a.shrinkBuf, a.setTyped, a.Buf8, a.Buf16, a.Buf32, 4),
n = 0,
i = 1,
s = 2;
function o(t) {
for (var e = t.length; --e >= 0; ) t[e] = 0;
}
var l = 0,
h = 1,
f = 2,
d = 29,
u = 256,
_ = u + 1 + d,
c = 30,
g = 19,
b = 2 * _ + 1,
w = 15,
p = 16,
v = 7,
m = 256,
k = 16,
y = 17,
x = 18,
z = [
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
2,
2,
2,
2,
3,
3,
3,
3,
4,
4,
4,
4,
5,
5,
5,
5,
0
],
A = [
0,
0,
0,
0,
1,
1,
2,
2,
3,
3,
4,
4,
5,
5,
6,
6,
7,
7,
8,
8,
9,
9,
10,
10,
11,
11,
12,
12,
13,
13
],
B = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
U = new Array(2 * (_ + 2));
o(U);
var E = new Array(2 * c);
o(E);
var R = new Array(512);
o(R);
var I = new Array(256);
o(I);
var Z = new Array(d);
o(Z);
var T,
N,
C,
D = new Array(c);
function M(t, e, a, r, n) {
(this.static_tree = t),
(this.extra_bits = e),
(this.extra_base = a),
(this.elems = r),
(this.max_length = n),
(this.has_stree = t && t.length);
}
function L(t, e) {
(this.dyn_tree = t), (this.max_code = 0), (this.stat_desc = e);
}
function O(t) {
return t < 256 ? R[t] : R[256 + (t >>> 7)];
}
function q(t, e) {
(t.pending_buf[t.pending++] = 255 & e),
(t.pending_buf[t.pending++] = (e >>> 8) & 255);
}
function F(t, e, a) {
t.bi_valid > p - a
? ((t.bi_buf |= (e << t.bi_valid) & 65535),
  q(t, t.bi_buf),
  (t.bi_buf = e >> (p - t.bi_valid)),
  (t.bi_valid += a - p))
: ((t.bi_buf |= (e << t.bi_valid) & 65535), (t.bi_valid += a));
}
function H(t, e, a) {
F(t, a[2 * e], a[2 * e + 1]);
}
function P(t, e) {
var a = 0;
do {
(a |= 1 & t), (t >>>= 1), (a <<= 1);
} while (--e > 0);
return a >>> 1;
}
function j(t, e, a) {
var r,
n,
i = new Array(w + 1),
s = 0;
for (r = 1; r <= w; r++) i[r] = s = (s + a[r - 1]) << 1;
for (n = 0; n <= e; n++) {
var o = t[2 * n + 1];
0 !== o && (t[2 * n] = P(i[o]++, o));
}
}
function G(t) {
var e;
for (e = 0; e < _; e++) t.dyn_ltree[2 * e] = 0;
for (e = 0; e < c; e++) t.dyn_dtree[2 * e] = 0;
for (e = 0; e < g; e++) t.bl_tree[2 * e] = 0;
(t.dyn_ltree[2 * m] = 1),
(t.opt_len = t.static_len = 0),
(t.last_lit = t.matches = 0);
}
function K(t) {
t.bi_valid > 8
? q(t, t.bi_buf)
: t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
(t.bi_buf = 0),
(t.bi_valid = 0);
}
function Y(t, e, a, r) {
var n = 2 * e,
i = 2 * a;
return t[n] < t[i] || (t[n] === t[i] && r[e] <= r[a]);
}
function X(t, e, a) {
for (
var r = t.heap[a], n = a << 1;
n <= t.heap_len &&
(n < t.heap_len && Y(e, t.heap[n + 1], t.heap[n], t.depth) && n++,
!Y(e, r, t.heap[n], t.depth));

)
(t.heap[a] = t.heap[n]), (a = n), (n <<= 1);
t.heap[a] = r;
}
function V(t, e, a) {
var r,
n,
i,
s,
o = 0;
if (0 !== t.last_lit)
do {
(r =
(t.pending_buf[t.d_buf + 2 * o] << 8) | t.pending_buf[t.d_buf + 2 * o + 1]),
(n = t.pending_buf[t.l_buf + o]),
o++,
0 === r
? H(t, n, e)
: (H(t, (i = I[n]) + u + 1, e),
  0 !== (s = z[i]) && F(t, (n -= Z[i]), s),
  H(t, (i = O(--r)), a),
  0 !== (s = A[i]) && F(t, (r -= D[i]), s));
} while (o < t.last_lit);
H(t, m, e);
}
function W(t, e) {
var a,
r,
n,
i = e.dyn_tree,
s = e.stat_desc.static_tree,
o = e.stat_desc.has_stree,
l = e.stat_desc.elems,
h = -1;
for (t.heap_len = 0, t.heap_max = b, a = 0; a < l; a++)
0 !== i[2 * a]
? ((t.heap[++t.heap_len] = h = a), (t.depth[a] = 0))
: (i[2 * a + 1] = 0);
for (; t.heap_len < 2; )
(i[2 * (n = t.heap[++t.heap_len] = h < 2 ? ++h : 0)] = 1),
(t.depth[n] = 0),
t.opt_len--,
o && (t.static_len -= s[2 * n + 1]);
for (e.max_code = h, a = t.heap_len >> 1; a >= 1; a--) X(t, i, a);
n = l;
do {
(a = t.heap[1]),
(t.heap[1] = t.heap[t.heap_len--]),
X(t, i, 1),
(r = t.heap[1]),
(t.heap[--t.heap_max] = a),
(t.heap[--t.heap_max] = r),
(i[2 * n] = i[2 * a] + i[2 * r]),
(t.depth[n] = (t.depth[a] >= t.depth[r] ? t.depth[a] : t.depth[r]) + 1),
(i[2 * a + 1] = i[2 * r + 1] = n),
(t.heap[1] = n++),
X(t, i, 1);
} while (t.heap_len >= 2);
(t.heap[--t.heap_max] = t.heap[1]),
(function(t, e) {
var a,
r,
n,
i,
s,
o,
l = e.dyn_tree,
h = e.max_code,
f = e.stat_desc.static_tree,
d = e.stat_desc.has_stree,
u = e.stat_desc.extra_bits,
_ = e.stat_desc.extra_base,
c = e.stat_desc.max_length,
g = 0;
for (i = 0; i <= w; i++) t.bl_count[i] = 0;
for (l[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < b; a++)
(i = l[2 * l[2 * (r = t.heap[a]) + 1] + 1] + 1) > c && ((i = c), g++),
(l[2 * r + 1] = i),
r > h ||
(t.bl_count[i]++,
(s = 0),
r >= _ && (s = u[r - _]),
(o = l[2 * r]),
(t.opt_len += o * (i + s)),
d && (t.static_len += o * (f[2 * r + 1] + s)));
if (0 !== g) {
do {
for (i = c - 1; 0 === t.bl_count[i]; ) i--;
t.bl_count[i]--, (t.bl_count[i + 1] += 2), t.bl_count[c]--, (g -= 2);
} while (g > 0);
for (i = c; 0 !== i; i--)
for (r = t.bl_count[i]; 0 !== r; )
(n = t.heap[--a]) > h ||
(l[2 * n + 1] !== i &&
((t.opt_len += (i - l[2 * n + 1]) * l[2 * n]), (l[2 * n + 1] = i)),
r--);
}
})(t, e),
j(i, h, t.bl_count);
}
function J(t, e, a) {
var r,
n,
i = -1,
s = e[1],
o = 0,
l = 7,
h = 4;
for (
0 === s && ((l = 138), (h = 3)), e[2 * (a + 1) + 1] = 65535, r = 0;
r <= a;
r++
)
(n = s),
(s = e[2 * (r + 1) + 1]),
(++o < l && n === s) ||
(o < h
? (t.bl_tree[2 * n] += o)
: 0 !== n
? (n !== i && t.bl_tree[2 * n]++, t.bl_tree[2 * k]++)
: o <= 10
? t.bl_tree[2 * y]++
: t.bl_tree[2 * x]++,
(o = 0),
(i = n),
0 === s
? ((l = 138), (h = 3))
: n === s
? ((l = 6), (h = 3))
: ((l = 7), (h = 4)));
}
function Q(t, e, a) {
var r,
n,
i = -1,
s = e[1],
o = 0,
l = 7,
h = 4;
for (0 === s && ((l = 138), (h = 3)), r = 0; r <= a; r++)
if (((n = s), (s = e[2 * (r + 1) + 1]), !(++o < l && n === s))) {
if (o < h)
do {
H(t, n, t.bl_tree);
} while (0 != --o);
else
0 !== n
? (n !== i && (H(t, n, t.bl_tree), o--), H(t, k, t.bl_tree), F(t, o - 3, 2))
: o <= 10
? (H(t, y, t.bl_tree), F(t, o - 3, 3))
: (H(t, x, t.bl_tree), F(t, o - 11, 7));
(o = 0),
(i = n),
0 === s
? ((l = 138), (h = 3))
: n === s
? ((l = 6), (h = 3))
: ((l = 7), (h = 4));
}
}
o(D);
var $ = !1;
function tt(t, e, r, n) {
F(t, (l << 1) + (n ? 1 : 0), 3),
(function(t, e, r, n) {
K(t),
n && (q(t, r), q(t, ~r)),
a.arraySet(t.pending_buf, t.window, e, r, t.pending),
(t.pending += r);
})(t, e, r, !0);
}
var et = {
_tr_init: function(t) {
$ ||
((function() {
var t,
e,
a,
r,
n,
i = new Array(w + 1);
for (a = 0, r = 0; r < d - 1; r++)
for (Z[r] = a, t = 0; t < 1 << z[r]; t++) I[a++] = r;
for (I[a - 1] = r, n = 0, r = 0; r < 16; r++)
for (D[r] = n, t = 0; t < 1 << A[r]; t++) R[n++] = r;
for (n >>= 7; r < c; r++)
for (D[r] = n << 7, t = 0; t < 1 << (A[r] - 7); t++) R[256 + n++] = r;
for (e = 0; e <= w; e++) i[e] = 0;
for (t = 0; t <= 143; ) (U[2 * t + 1] = 8), t++, i[8]++;
for (; t <= 255; ) (U[2 * t + 1] = 9), t++, i[9]++;
for (; t <= 279; ) (U[2 * t + 1] = 7), t++, i[7]++;
for (; t <= 287; ) (U[2 * t + 1] = 8), t++, i[8]++;
for (j(U, _ + 1, i), t = 0; t < c; t++)
(E[2 * t + 1] = 5), (E[2 * t] = P(t, 5));
(T = new M(U, z, u + 1, _, w)),
(N = new M(E, A, 0, c, w)),
(C = new M(new Array(0), B, 0, g, v));
})(),
($ = !0)),
(t.l_desc = new L(t.dyn_ltree, T)),
(t.d_desc = new L(t.dyn_dtree, N)),
(t.bl_desc = new L(t.bl_tree, C)),
(t.bi_buf = 0),
(t.bi_valid = 0),
G(t);
},
_tr_stored_block: tt,
_tr_flush_block: function(t, e, a, o) {
var l,
d,
_ = 0;
t.level > 0
? (t.strm.data_type === s &&
  (t.strm.data_type = (function(t) {
  var e,
  a = 4093624447;
  for (e = 0; e <= 31; e++, a >>>= 1)
  if (1 & a && 0 !== t.dyn_ltree[2 * e]) return n;
  if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26])
  return i;
  for (e = 32; e < u; e++) if (0 !== t.dyn_ltree[2 * e]) return i;
  return n;
  })(t)),
  W(t, t.l_desc),
  W(t, t.d_desc),
  (_ = (function(t) {
  var e;
  for (
  J(t, t.dyn_ltree, t.l_desc.max_code),
  J(t, t.dyn_dtree, t.d_desc.max_code),
  W(t, t.bl_desc),
  e = g - 1;
  e >= 3 && 0 === t.bl_tree[2 * S[e] + 1];
  e--
  );
  return (t.opt_len += 3 * (e + 1) + 5 + 5 + 4), e;
  })(t)),
  (l = (t.opt_len + 3 + 7) >>> 3),
  (d = (t.static_len + 3 + 7) >>> 3) <= l && (l = d))
: (l = d = a + 5),
a + 4 <= l && -1 !== e
? tt(t, e, a, o)
: t.strategy === r || d === l
? (F(t, (h << 1) + (o ? 1 : 0), 3), V(t, U, E))
: (F(t, (f << 1) + (o ? 1 : 0), 3),
  (function(t, e, a, r) {
  var n;
  for (F(t, e - 257, 5), F(t, a - 1, 5), F(t, r - 4, 4), n = 0; n < r; n++)
  F(t, t.bl_tree[2 * S[n] + 1], 3);
  Q(t, t.dyn_ltree, e - 1), Q(t, t.dyn_dtree, a - 1);
  })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, _ + 1),
  V(t, t.dyn_ltree, t.dyn_dtree)),
G(t),
o && K(t);
},
_tr_tally: function(t, e, a) {
return (
(t.pending_buf[t.d_buf + 2 * t.last_lit] = (e >>> 8) & 255),
(t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e),
(t.pending_buf[t.l_buf + t.last_lit] = 255 & a),
t.last_lit++,
0 === e
? t.dyn_ltree[2 * a]++
: (t.matches++,
  e--,
  t.dyn_ltree[2 * (I[a] + u + 1)]++,
  t.dyn_dtree[2 * O(e)]++),
t.last_lit === t.lit_bufsize - 1
);
},
_tr_align: function(t) {
F(t, h << 1, 3),
H(t, m, U),
(function(t) {
16 === t.bi_valid
? (q(t, t.bi_buf), (t.bi_buf = 0), (t.bi_valid = 0))
: t.bi_valid >= 8 &&
  ((t.pending_buf[t.pending++] = 255 & t.bi_buf),
  (t.bi_buf >>= 8),
  (t.bi_valid -= 8));
})(t);
}
};
var at = function(t, e, a, r) {
for (var n = (65535 & t) | 0, i = ((t >>> 16) & 65535) | 0, s = 0; 0 !== a; ) {
a -= s = a > 2e3 ? 2e3 : a;
do {
i = (i + (n = (n + e[r++]) | 0)) | 0;
} while (--s);
(n %= 65521), (i %= 65521);
}
return n | (i << 16) | 0;
};
var rt = (function() {
for (var t, e = [], a = 0; a < 256; a++) {
t = a;
for (var r = 0; r < 8; r++) t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1;
e[a] = t;
}
return e;
})();
var nt,
it = function(t, e, a, r) {
var n = rt,
i = r + a;
t ^= -1;
for (var s = r; s < i; s++) t = (t >>> 8) ^ n[255 & (t ^ e[s])];
return -1 ^ t;
},
st = {
2: "need dictionary",
1: "stream end",
0: "",
"-1": "file error",
"-2": "stream error",
"-3": "data error",
"-4": "insufficient memory",
"-5": "buffer error",
"-6": "incompatible version"
},
ot = 0,
lt = 1,
ht = 3,
ft = 4,
dt = 5,
ut = 0,
_t = 1,
ct = -2,
gt = -3,
bt = -5,
wt = -1,
pt = 1,
vt = 2,
mt = 3,
kt = 4,
yt = 0,
xt = 2,
zt = 8,
At = 9,
Bt = 15,
St = 8,
Ut = 286,
Et = 30,
Rt = 19,
It = 2 * Ut + 1,
Zt = 15,
Tt = 3,
Nt = 258,
Ct = Nt + Tt + 1,
Dt = 32,
Mt = 42,
Lt = 69,
Ot = 73,
qt = 91,
Ft = 103,
Ht = 113,
Pt = 666,
jt = 1,
Gt = 2,
Kt = 3,
Yt = 4,
Xt = 3;
function Vt(t, e) {
return (t.msg = st[e]), e;
}
function Wt(t) {
return (t << 1) - (t > 4 ? 9 : 0);
}
function Jt(t) {
for (var e = t.length; --e >= 0; ) t[e] = 0;
}
function Qt(t) {
var e = t.state,
r = e.pending;
r > t.avail_out && (r = t.avail_out),
0 !== r &&
(a.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out),
(t.next_out += r),
(e.pending_out += r),
(t.total_out += r),
(t.avail_out -= r),
(e.pending -= r),
0 === e.pending && (e.pending_out = 0));
}
function $t(t, e) {
et._tr_flush_block(
t,
t.block_start >= 0 ? t.block_start : -1,
t.strstart - t.block_start,
e
),
(t.block_start = t.strstart),
Qt(t.strm);
}
function te(t, e) {
t.pending_buf[t.pending++] = e;
}
function ee(t, e) {
(t.pending_buf[t.pending++] = (e >>> 8) & 255),
(t.pending_buf[t.pending++] = 255 & e);
}
function ae(t, e) {
var a,
r,
n = t.max_chain_length,
i = t.strstart,
s = t.prev_length,
o = t.nice_match,
l = t.strstart > t.w_size - Ct ? t.strstart - (t.w_size - Ct) : 0,
h = t.window,
f = t.w_mask,
d = t.prev,
u = t.strstart + Nt,
_ = h[i + s - 1],
c = h[i + s];
t.prev_length >= t.good_match && (n >>= 2),
o > t.lookahead && (o = t.lookahead);
do {
if (
h[(a = e) + s] === c &&
h[a + s - 1] === _ &&
h[a] === h[i] &&
h[++a] === h[i + 1]
) {
(i += 2), a++;
do {} while (
h[++i] === h[++a] &&
h[++i] === h[++a] &&
h[++i] === h[++a] &&
h[++i] === h[++a] &&
h[++i] === h[++a] &&
h[++i] === h[++a] &&
h[++i] === h[++a] &&
h[++i] === h[++a] &&
i < u
);
if (((r = Nt - (u - i)), (i = u - Nt), r > s)) {
if (((t.match_start = e), (s = r), r >= o)) break;
(_ = h[i + s - 1]), (c = h[i + s]);
}
}
} while ((e = d[e & f]) > l && 0 != --n);
return s <= t.lookahead ? s : t.lookahead;
}
function re(t) {
var e,
r,
n,
i,
s,
o,
l,
h,
f,
d,
u = t.w_size;
do {
if (
((i = t.window_size - t.lookahead - t.strstart), t.strstart >= u + (u - Ct))
) {
a.arraySet(t.window, t.window, u, u, 0),
(t.match_start -= u),
(t.strstart -= u),
(t.block_start -= u),
(e = r = t.hash_size);
do {
(n = t.head[--e]), (t.head[e] = n >= u ? n - u : 0);
} while (--r);
e = r = u;
do {
(n = t.prev[--e]), (t.prev[e] = n >= u ? n - u : 0);
} while (--r);
i += u;
}
if (0 === t.strm.avail_in) break;
if (
((o = t.strm),
(l = t.window),
(h = t.strstart + t.lookahead),
(f = i),
(d = void 0),
(d = o.avail_in) > f && (d = f),
(r =
0 === d
? 0
: ((o.avail_in -= d),
  a.arraySet(l, o.input, o.next_in, d, h),
  1 === o.state.wrap
  ? (o.adler = at(o.adler, l, d, h))
  : 2 === o.state.wrap && (o.adler = it(o.adler, l, d, h)),
  (o.next_in += d),
  (o.total_in += d),
  d)),
(t.lookahead += r),
t.lookahead + t.insert >= Tt)
)
for (
s = t.strstart - t.insert,
t.ins_h = t.window[s],
t.ins_h = ((t.ins_h << t.hash_shift) ^ t.window[s + 1]) & t.hash_mask;
t.insert &&
((t.ins_h = ((t.ins_h << t.hash_shift) ^ t.window[s + Tt - 1]) & t.hash_mask),
(t.prev[s & t.w_mask] = t.head[t.ins_h]),
(t.head[t.ins_h] = s),
s++,
t.insert--,
!(t.lookahead + t.insert < Tt));

);
} while (t.lookahead < Ct && 0 !== t.strm.avail_in);
}
function ne(t, e) {
for (var a, r; ; ) {
if (t.lookahead < Ct) {
if ((re(t), t.lookahead < Ct && e === ot)) return jt;
if (0 === t.lookahead) break;
}
if (
((a = 0),
t.lookahead >= Tt &&
((t.ins_h =
((t.ins_h << t.hash_shift) ^ t.window[t.strstart + Tt - 1]) & t.hash_mask),
(a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
(t.head[t.ins_h] = t.strstart)),
0 !== a && t.strstart - a <= t.w_size - Ct && (t.match_length = ae(t, a)),
t.match_length >= Tt)
)
if (
((r = et._tr_tally(t, t.strstart - t.match_start, t.match_length - Tt)),
(t.lookahead -= t.match_length),
t.match_length <= t.max_lazy_match && t.lookahead >= Tt)
) {
t.match_length--;
do {
t.strstart++,
(t.ins_h =
((t.ins_h << t.hash_shift) ^ t.window[t.strstart + Tt - 1]) & t.hash_mask),
(a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
(t.head[t.ins_h] = t.strstart);
} while (0 != --t.match_length);
t.strstart++;
} else
(t.strstart += t.match_length),
(t.match_length = 0),
(t.ins_h = t.window[t.strstart]),
(t.ins_h =
((t.ins_h << t.hash_shift) ^ t.window[t.strstart + 1]) & t.hash_mask);
else
(r = et._tr_tally(t, 0, t.window[t.strstart])), t.lookahead--, t.strstart++;
if (r && ($t(t, !1), 0 === t.strm.avail_out)) return jt;
}
return (
(t.insert = t.strstart < Tt - 1 ? t.strstart : Tt - 1),
e === ft
? ($t(t, !0), 0 === t.strm.avail_out ? Kt : Yt)
: t.last_lit && ($t(t, !1), 0 === t.strm.avail_out)
? jt
: Gt
);
}
function ie(t, e) {
for (var a, r, n; ; ) {
if (t.lookahead < Ct) {
if ((re(t), t.lookahead < Ct && e === ot)) return jt;
if (0 === t.lookahead) break;
}
if (
((a = 0),
t.lookahead >= Tt &&
((t.ins_h =
((t.ins_h << t.hash_shift) ^ t.window[t.strstart + Tt - 1]) & t.hash_mask),
(a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
(t.head[t.ins_h] = t.strstart)),
(t.prev_length = t.match_length),
(t.prev_match = t.match_start),
(t.match_length = Tt - 1),
0 !== a &&
t.prev_length < t.max_lazy_match &&
t.strstart - a <= t.w_size - Ct &&
((t.match_length = ae(t, a)),
t.match_length <= 5 &&
(t.strategy === pt ||
(t.match_length === Tt && t.strstart - t.match_start > 4096)) &&
(t.match_length = Tt - 1)),
t.prev_length >= Tt && t.match_length <= t.prev_length)
) {
(n = t.strstart + t.lookahead - Tt),
(r = et._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - Tt)),
(t.lookahead -= t.prev_length - 1),
(t.prev_length -= 2);
do {
++t.strstart <= n &&
((t.ins_h =
((t.ins_h << t.hash_shift) ^ t.window[t.strstart + Tt - 1]) & t.hash_mask),
(a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
(t.head[t.ins_h] = t.strstart));
} while (0 != --t.prev_length);
if (
((t.match_available = 0),
(t.match_length = Tt - 1),
t.strstart++,
r && ($t(t, !1), 0 === t.strm.avail_out))
)
return jt;
} else if (t.match_available) {
if (
((r = et._tr_tally(t, 0, t.window[t.strstart - 1])) && $t(t, !1),
t.strstart++,
t.lookahead--,
0 === t.strm.avail_out)
)
return jt;
} else (t.match_available = 1), t.strstart++, t.lookahead--;
}
return (
t.match_available &&
((r = et._tr_tally(t, 0, t.window[t.strstart - 1])), (t.match_available = 0)),
(t.insert = t.strstart < Tt - 1 ? t.strstart : Tt - 1),
e === ft
? ($t(t, !0), 0 === t.strm.avail_out ? Kt : Yt)
: t.last_lit && ($t(t, !1), 0 === t.strm.avail_out)
? jt
: Gt
);
}
function se(t, e, a, r, n) {
(this.good_length = t),
(this.max_lazy = e),
(this.nice_length = a),
(this.max_chain = r),
(this.func = n);
}
function oe() {
(this.strm = null),
(this.status = 0),
(this.pending_buf = null),
(this.pending_buf_size = 0),
(this.pending_out = 0),
(this.pending = 0),
(this.wrap = 0),
(this.gzhead = null),
(this.gzindex = 0),
(this.method = zt),
(this.last_flush = -1),
(this.w_size = 0),
(this.w_bits = 0),
(this.w_mask = 0),
(this.window = null),
(this.window_size = 0),
(this.prev = null),
(this.head = null),
(this.ins_h = 0),
(this.hash_size = 0),
(this.hash_bits = 0),
(this.hash_mask = 0),
(this.hash_shift = 0),
(this.block_start = 0),
(this.match_length = 0),
(this.prev_match = 0),
(this.match_available = 0),
(this.strstart = 0),
(this.match_start = 0),
(this.lookahead = 0),
(this.prev_length = 0),
(this.max_chain_length = 0),
(this.max_lazy_match = 0),
(this.level = 0),
(this.strategy = 0),
(this.good_match = 0),
(this.nice_match = 0),
(this.dyn_ltree = new a.Buf16(2 * It)),
(this.dyn_dtree = new a.Buf16(2 * (2 * Et + 1))),
(this.bl_tree = new a.Buf16(2 * (2 * Rt + 1))),
Jt(this.dyn_ltree),
Jt(this.dyn_dtree),
Jt(this.bl_tree),
(this.l_desc = null),
(this.d_desc = null),
(this.bl_desc = null),
(this.bl_count = new a.Buf16(Zt + 1)),
(this.heap = new a.Buf16(2 * Ut + 1)),
Jt(this.heap),
(this.heap_len = 0),
(this.heap_max = 0),
(this.depth = new a.Buf16(2 * Ut + 1)),
Jt(this.depth),
(this.l_buf = 0),
(this.lit_bufsize = 0),
(this.last_lit = 0),
(this.d_buf = 0),
(this.opt_len = 0),
(this.static_len = 0),
(this.matches = 0),
(this.insert = 0),
(this.bi_buf = 0),
(this.bi_valid = 0);
}
function le(t) {
var e;
return t && t.state
? ((t.total_in = t.total_out = 0),
  (t.data_type = xt),
  ((e = t.state).pending = 0),
  (e.pending_out = 0),
  e.wrap < 0 && (e.wrap = -e.wrap),
  (e.status = e.wrap ? Mt : Ht),
  (t.adler = 2 === e.wrap ? 0 : 1),
  (e.last_flush = ot),
  et._tr_init(e),
  ut)
: Vt(t, ct);
}
function he(t) {
var e,
a = le(t);
return (
a === ut &&
(((e = t.state).window_size = 2 * e.w_size),
Jt(e.head),
(e.max_lazy_match = nt[e.level].max_lazy),
(e.good_match = nt[e.level].good_length),
(e.nice_match = nt[e.level].nice_length),
(e.max_chain_length = nt[e.level].max_chain),
(e.strstart = 0),
(e.block_start = 0),
(e.lookahead = 0),
(e.insert = 0),
(e.match_length = e.prev_length = Tt - 1),
(e.match_available = 0),
(e.ins_h = 0)),
a
);
}
function fe(t, e, r, n, i, s) {
if (!t) return ct;
var o = 1;
if (
(e === wt && (e = 6),
n < 0 ? ((o = 0), (n = -n)) : n > 15 && ((o = 2), (n -= 16)),
i < 1 ||
i > At ||
r !== zt ||
n < 8 ||
n > 15 ||
e < 0 ||
e > 9 ||
s < 0 ||
s > kt)
)
return Vt(t, ct);
8 === n && (n = 9);
var l = new oe();
return (
(t.state = l),
(l.strm = t),
(l.wrap = o),
(l.gzhead = null),
(l.w_bits = n),
(l.w_size = 1 << l.w_bits),
(l.w_mask = l.w_size - 1),
(l.hash_bits = i + 7),
(l.hash_size = 1 << l.hash_bits),
(l.hash_mask = l.hash_size - 1),
(l.hash_shift = ~~((l.hash_bits + Tt - 1) / Tt)),
(l.window = new a.Buf8(2 * l.w_size)),
(l.head = new a.Buf16(l.hash_size)),
(l.prev = new a.Buf16(l.w_size)),
(l.lit_bufsize = 1 << (i + 6)),
(l.pending_buf_size = 4 * l.lit_bufsize),
(l.pending_buf = new a.Buf8(l.pending_buf_size)),
(l.d_buf = 1 * l.lit_bufsize),
(l.l_buf = 3 * l.lit_bufsize),
(l.level = e),
(l.strategy = s),
(l.method = r),
he(t)
);
}
nt = [
new se(0, 0, 0, 0, function(t, e) {
var a = 65535;
for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5); ; ) {
if (t.lookahead <= 1) {
if ((re(t), 0 === t.lookahead && e === ot)) return jt;
if (0 === t.lookahead) break;
}
(t.strstart += t.lookahead), (t.lookahead = 0);
var r = t.block_start + a;
if (
(0 === t.strstart || t.strstart >= r) &&
((t.lookahead = t.strstart - r),
(t.strstart = r),
$t(t, !1),
0 === t.strm.avail_out)
)
return jt;
if (
t.strstart - t.block_start >= t.w_size - Ct &&
($t(t, !1), 0 === t.strm.avail_out)
)
return jt;
}
return (
(t.insert = 0),
e === ft
? ($t(t, !0), 0 === t.strm.avail_out ? Kt : Yt)
: (t.strstart > t.block_start && ($t(t, !1), t.strm.avail_out), jt)
);
}),
new se(4, 4, 8, 4, ne),
new se(4, 5, 16, 8, ne),
new se(4, 6, 32, 32, ne),
new se(4, 4, 16, 16, ie),
new se(8, 16, 32, 32, ie),
new se(8, 16, 128, 128, ie),
new se(8, 32, 128, 256, ie),
new se(32, 128, 258, 1024, ie),
new se(32, 258, 258, 4096, ie)
];
var de = {
deflateInit: function(t, e) {
return fe(t, e, zt, Bt, St, yt);
},
deflateInit2: fe,
deflateReset: he,
deflateResetKeep: le,
deflateSetHeader: function(t, e) {
return t && t.state
? 2 !== t.state.wrap
  ? ct
  : ((t.state.gzhead = e), ut)
: ct;
},
deflate: function(t, e) {
var a, r, n, i;
if (!t || !t.state || e > dt || e < 0) return t ? Vt(t, ct) : ct;
if (
((r = t.state),
!t.output || (!t.input && 0 !== t.avail_in) || (r.status === Pt && e !== ft))
)
return Vt(t, 0 === t.avail_out ? bt : ct);
if (((r.strm = t), (a = r.last_flush), (r.last_flush = e), r.status === Mt))
if (2 === r.wrap)
(t.adler = 0),
te(r, 31),
te(r, 139),
te(r, 8),
r.gzhead
? (te(
  r,
  (r.gzhead.text ? 1 : 0) +
  (r.gzhead.hcrc ? 2 : 0) +
  (r.gzhead.extra ? 4 : 0) +
  (r.gzhead.name ? 8 : 0) +
  (r.gzhead.comment ? 16 : 0)
  ),
  te(r, 255 & r.gzhead.time),
  te(r, (r.gzhead.time >> 8) & 255),
  te(r, (r.gzhead.time >> 16) & 255),
  te(r, (r.gzhead.time >> 24) & 255),
  te(r, 9 === r.level ? 2 : r.strategy >= vt || r.level < 2 ? 4 : 0),
  te(r, 255 & r.gzhead.os),
  r.gzhead.extra &&
  r.gzhead.extra.length &&
  (te(r, 255 & r.gzhead.extra.length),
  te(r, (r.gzhead.extra.length >> 8) & 255)),
  r.gzhead.hcrc && (t.adler = it(t.adler, r.pending_buf, r.pending, 0)),
  (r.gzindex = 0),
  (r.status = Lt))
: (te(r, 0),
  te(r, 0),
  te(r, 0),
  te(r, 0),
  te(r, 0),
  te(r, 9 === r.level ? 2 : r.strategy >= vt || r.level < 2 ? 4 : 0),
  te(r, Xt),
  (r.status = Ht));
else {
var s = (zt + ((r.w_bits - 8) << 4)) << 8;
(s |=
(r.strategy >= vt || r.level < 2
? 0
: r.level < 6
? 1
: 6 === r.level
? 2
: 3) << 6),
0 !== r.strstart && (s |= Dt),
(s += 31 - (s % 31)),
(r.status = Ht),
ee(r, s),
0 !== r.strstart && (ee(r, t.adler >>> 16), ee(r, 65535 & t.adler)),
(t.adler = 1);
}
if (r.status === Lt)
if (r.gzhead.extra) {
for (
n = r.pending;
r.gzindex < (65535 & r.gzhead.extra.length) &&
(r.pending !== r.pending_buf_size ||
(r.gzhead.hcrc &&
r.pending > n &&
(t.adler = it(t.adler, r.pending_buf, r.pending - n, n)),
Qt(t),
(n = r.pending),
r.pending !== r.pending_buf_size));

)
te(r, 255 & r.gzhead.extra[r.gzindex]), r.gzindex++;
r.gzhead.hcrc &&
r.pending > n &&
(t.adler = it(t.adler, r.pending_buf, r.pending - n, n)),
r.gzindex === r.gzhead.extra.length && ((r.gzindex = 0), (r.status = Ot));
} else r.status = Ot;
if (r.status === Ot)
if (r.gzhead.name) {
n = r.pending;
do {
if (
r.pending === r.pending_buf_size &&
(r.gzhead.hcrc &&
r.pending > n &&
(t.adler = it(t.adler, r.pending_buf, r.pending - n, n)),
Qt(t),
(n = r.pending),
r.pending === r.pending_buf_size)
) {
i = 1;
break;
}
(i =
r.gzindex < r.gzhead.name.length
? 255 & r.gzhead.name.charCodeAt(r.gzindex++)
: 0),
te(r, i);
} while (0 !== i);
r.gzhead.hcrc &&
r.pending > n &&
(t.adler = it(t.adler, r.pending_buf, r.pending - n, n)),
0 === i && ((r.gzindex = 0), (r.status = qt));
} else r.status = qt;
if (r.status === qt)
if (r.gzhead.comment) {
n = r.pending;
do {
if (
r.pending === r.pending_buf_size &&
(r.gzhead.hcrc &&
r.pending > n &&
(t.adler = it(t.adler, r.pending_buf, r.pending - n, n)),
Qt(t),
(n = r.pending),
r.pending === r.pending_buf_size)
) {
i = 1;
break;
}
(i =
r.gzindex < r.gzhead.comment.length
? 255 & r.gzhead.comment.charCodeAt(r.gzindex++)
: 0),
te(r, i);
} while (0 !== i);
r.gzhead.hcrc &&
r.pending > n &&
(t.adler = it(t.adler, r.pending_buf, r.pending - n, n)),
0 === i && (r.status = Ft);
} else r.status = Ft;
if (
(r.status === Ft &&
(r.gzhead.hcrc
? (r.pending + 2 > r.pending_buf_size && Qt(t),
  r.pending + 2 <= r.pending_buf_size &&
  (te(r, 255 & t.adler),
  te(r, (t.adler >> 8) & 255),
  (t.adler = 0),
  (r.status = Ht)))
: (r.status = Ht)),
0 !== r.pending)
) {
if ((Qt(t), 0 === t.avail_out)) return (r.last_flush = -1), ut;
} else if (0 === t.avail_in && Wt(e) <= Wt(a) && e !== ft) return Vt(t, bt);
if (r.status === Pt && 0 !== t.avail_in) return Vt(t, bt);
if (0 !== t.avail_in || 0 !== r.lookahead || (e !== ot && r.status !== Pt)) {
var o =
r.strategy === vt
? (function(t, e) {
  for (var a; ; ) {
  if (0 === t.lookahead && (re(t), 0 === t.lookahead)) {
  if (e === ot) return jt;
  break;
  }
  if (
  ((t.match_length = 0),
  (a = et._tr_tally(t, 0, t.window[t.strstart])),
  t.lookahead--,
  t.strstart++,
  a && ($t(t, !1), 0 === t.strm.avail_out))
  )
  return jt;
  }
  return (
  (t.insert = 0),
  e === ft
  ? ($t(t, !0), 0 === t.strm.avail_out ? Kt : Yt)
  : t.last_lit && ($t(t, !1), 0 === t.strm.avail_out)
  ? jt
  : Gt
  );
  })(r, e)
: r.strategy === mt
? (function(t, e) {
  for (var a, r, n, i, s = t.window; ; ) {
  if (t.lookahead <= Nt) {
  if ((re(t), t.lookahead <= Nt && e === ot)) return jt;
  if (0 === t.lookahead) break;
  }
  if (
  ((t.match_length = 0),
  t.lookahead >= Tt &&
  t.strstart > 0 &&
  (r = s[(n = t.strstart - 1)]) === s[++n] &&
  r === s[++n] &&
  r === s[++n])
  ) {
  i = t.strstart + Nt;
  do {} while (
  r === s[++n] &&
  r === s[++n] &&
  r === s[++n] &&
  r === s[++n] &&
  r === s[++n] &&
  r === s[++n] &&
  r === s[++n] &&
  r === s[++n] &&
  n < i
  );
  (t.match_length = Nt - (i - n)),
  t.match_length > t.lookahead && (t.match_length = t.lookahead);
  }
  if (
  (t.match_length >= Tt
  ? ((a = et._tr_tally(t, 1, t.match_length - Tt)),
    (t.lookahead -= t.match_length),
    (t.strstart += t.match_length),
    (t.match_length = 0))
  : ((a = et._tr_tally(t, 0, t.window[t.strstart])),
    t.lookahead--,
    t.strstart++),
  a && ($t(t, !1), 0 === t.strm.avail_out))
  )
  return jt;
  }
  return (
  (t.insert = 0),
  e === ft
  ? ($t(t, !0), 0 === t.strm.avail_out ? Kt : Yt)
  : t.last_lit && ($t(t, !1), 0 === t.strm.avail_out)
  ? jt
  : Gt
  );
  })(r, e)
: nt[r.level].func(r, e);
if (((o !== Kt && o !== Yt) || (r.status = Pt), o === jt || o === Kt))
return 0 === t.avail_out && (r.last_flush = -1), ut;
if (
o === Gt &&
(e === lt
? et._tr_align(r)
: e !== dt &&
  (et._tr_stored_block(r, 0, 0, !1),
  e === ht &&
  (Jt(r.head),
  0 === r.lookahead &&
  ((r.strstart = 0), (r.block_start = 0), (r.insert = 0)))),
Qt(t),
0 === t.avail_out)
)
return (r.last_flush = -1), ut;
}
return e !== ft
? ut
: r.wrap <= 0
? _t
: (2 === r.wrap
  ? (te(r, 255 & t.adler),
    te(r, (t.adler >> 8) & 255),
    te(r, (t.adler >> 16) & 255),
    te(r, (t.adler >> 24) & 255),
    te(r, 255 & t.total_in),
    te(r, (t.total_in >> 8) & 255),
    te(r, (t.total_in >> 16) & 255),
    te(r, (t.total_in >> 24) & 255))
  : (ee(r, t.adler >>> 16), ee(r, 65535 & t.adler)),
  Qt(t),
  r.wrap > 0 && (r.wrap = -r.wrap),
  0 !== r.pending ? ut : _t);
},
deflateEnd: function(t) {
var e;
return t && t.state
? (e = t.state.status) !== Mt &&
  e !== Lt &&
  e !== Ot &&
  e !== qt &&
  e !== Ft &&
  e !== Ht &&
  e !== Pt
  ? Vt(t, ct)
  : ((t.state = null), e === Ht ? Vt(t, gt) : ut)
: ct;
},
deflateSetDictionary: function(t, e) {
var r,
n,
i,
s,
o,
l,
h,
f,
d = e.length;
if (!t || !t.state) return ct;
if (
2 === (s = (r = t.state).wrap) ||
(1 === s && r.status !== Mt) ||
r.lookahead
)
return ct;
for (
1 === s && (t.adler = at(t.adler, e, d, 0)),
r.wrap = 0,
d >= r.w_size &&
(0 === s && (Jt(r.head), (r.strstart = 0), (r.block_start = 0), (r.insert = 0)),
(f = new a.Buf8(r.w_size)),
a.arraySet(f, e, d - r.w_size, r.w_size, 0),
(e = f),
(d = r.w_size)),
o = t.avail_in,
l = t.next_in,
h = t.input,
t.avail_in = d,
t.next_in = 0,
t.input = e,
re(r);
r.lookahead >= Tt;

) {
(n = r.strstart), (i = r.lookahead - (Tt - 1));
do {
(r.ins_h = ((r.ins_h << r.hash_shift) ^ r.window[n + Tt - 1]) & r.hash_mask),
(r.prev[n & r.w_mask] = r.head[r.ins_h]),
(r.head[r.ins_h] = n),
n++;
} while (--i);
(r.strstart = n), (r.lookahead = Tt - 1), re(r);
}
return (
(r.strstart += r.lookahead),
(r.block_start = r.strstart),
(r.insert = r.lookahead),
(r.lookahead = 0),
(r.match_length = r.prev_length = Tt - 1),
(r.match_available = 0),
(t.next_in = l),
(t.input = h),
(t.avail_in = o),
(r.wrap = s),
ut
);
},
deflateInfo: "pako deflate (from Nodeca project)"
},
ue = !0,
_e = !0;
try {
String.fromCharCode.apply(null, [0]);
} catch (t) {
ue = !1;
}
try {
String.fromCharCode.apply(null, new Uint8Array(1));
} catch (t) {
_e = !1;
}
for (var ce = new a.Buf8(256), ge = 0; ge < 256; ge++)
ce[ge] =
ge >= 252
? 6
: ge >= 248
? 5
: ge >= 240
? 4
: ge >= 224
? 3
: ge >= 192
? 2
: 1;
ce[254] = ce[254] = 1;
function be(t, e) {
if (e < 65534 && ((t.subarray && _e) || (!t.subarray && ue)))
return String.fromCharCode.apply(null, a.shrinkBuf(t, e));
for (var r = "", n = 0; n < e; n++) r += String.fromCharCode(t[n]);
return r;
}
var we = {
string2buf: function(t) {
var e,
r,
n,
i,
s,
o = t.length,
l = 0;
for (i = 0; i < o; i++)
55296 == (64512 & (r = t.charCodeAt(i))) &&
i + 1 < o &&
56320 == (64512 & (n = t.charCodeAt(i + 1))) &&
((r = 65536 + ((r - 55296) << 10) + (n - 56320)), i++),
(l += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4);
for (e = new a.Buf8(l), s = 0, i = 0; s < l; i++)
55296 == (64512 & (r = t.charCodeAt(i))) &&
i + 1 < o &&
56320 == (64512 & (n = t.charCodeAt(i + 1))) &&
((r = 65536 + ((r - 55296) << 10) + (n - 56320)), i++),
r < 128
? (e[s++] = r)
: r < 2048
? ((e[s++] = 192 | (r >>> 6)), (e[s++] = 128 | (63 & r)))
: r < 65536
? ((e[s++] = 224 | (r >>> 12)),
  (e[s++] = 128 | ((r >>> 6) & 63)),
  (e[s++] = 128 | (63 & r)))
: ((e[s++] = 240 | (r >>> 18)),
  (e[s++] = 128 | ((r >>> 12) & 63)),
  (e[s++] = 128 | ((r >>> 6) & 63)),
  (e[s++] = 128 | (63 & r)));
return e;
},
buf2binstring: function(t) {
return be(t, t.length);
},
binstring2buf: function(t) {
for (var e = new a.Buf8(t.length), r = 0, n = e.length; r < n; r++)
e[r] = t.charCodeAt(r);
return e;
},
buf2string: function(t, e) {
var a,
r,
n,
i,
s = e || t.length,
o = new Array(2 * s);
for (r = 0, a = 0; a < s; )
if ((n = t[a++]) < 128) o[r++] = n;
else if ((i = ce[n]) > 4) (o[r++] = 65533), (a += i - 1);
else {
for (n &= 2 === i ? 31 : 3 === i ? 15 : 7; i > 1 && a < s; )
(n = (n << 6) | (63 & t[a++])), i--;
i > 1
? (o[r++] = 65533)
: n < 65536
? (o[r++] = n)
: ((n -= 65536),
  (o[r++] = 55296 | ((n >> 10) & 1023)),
  (o[r++] = 56320 | (1023 & n)));
}
return be(o, r);
},
utf8border: function(t, e) {
var a;
for (
(e = e || t.length) > t.length && (e = t.length), a = e - 1;
a >= 0 && 128 == (192 & t[a]);

)
a--;
return a < 0 ? e : 0 === a ? e : a + ce[t[a]] > e ? a : e;
}
};
var pe = function() {
(this.input = null),
(this.next_in = 0),
(this.avail_in = 0),
(this.total_in = 0),
(this.output = null),
(this.next_out = 0),
(this.avail_out = 0),
(this.total_out = 0),
(this.msg = ""),
(this.state = null),
(this.data_type = 2),
(this.adler = 0);
},
ve = Object.prototype.toString,
me = 0,
ke = -1,
ye = 0,
xe = 8;
function ze(t) {
if (!(this instanceof ze)) return new ze(t);
this.options = a.assign(
{
level: ke,
method: xe,
chunkSize: 16384,
windowBits: 15,
memLevel: 8,
strategy: ye,
to: ""
},
t || {}
);
var e = this.options;
e.raw && e.windowBits > 0
? (e.windowBits = -e.windowBits)
: e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16),
(this.err = 0),
(this.msg = ""),
(this.ended = !1),
(this.chunks = []),
(this.strm = new pe()),
(this.strm.avail_out = 0);
var r = de.deflateInit2(
this.strm,
e.level,
e.method,
e.windowBits,
e.memLevel,
e.strategy
);
if (r !== me) throw new Error(st[r]);
if ((e.header && de.deflateSetHeader(this.strm, e.header), e.dictionary)) {
var n;
if (
((n =
"string" == typeof e.dictionary
? we.string2buf(e.dictionary)
: "[object ArrayBuffer]" === ve.call(e.dictionary)
? new Uint8Array(e.dictionary)
: e.dictionary),
(r = de.deflateSetDictionary(this.strm, n)) !== me)
)
throw new Error(st[r]);
this._dict_set = !0;
}
}
function Ae(t, e) {
var a = new ze(e);
if ((a.push(t, !0), a.err)) throw a.msg || st[a.err];
return a.result;
}
(ze.prototype.push = function(t, e) {
var r,
n,
i = this.strm,
s = this.options.chunkSize;
if (this.ended) return !1;
(n = e === ~~e ? e : !0 === e ? 4 : 0),
"string" == typeof t
? (i.input = we.string2buf(t))
: "[object ArrayBuffer]" === ve.call(t)
? (i.input = new Uint8Array(t))
: (i.input = t),
(i.next_in = 0),
(i.avail_in = i.input.length);
do {
if (
(0 === i.avail_out &&
((i.output = new a.Buf8(s)), (i.next_out = 0), (i.avail_out = s)),
1 !== (r = de.deflate(i, n)) && r !== me)
)
return this.onEnd(r), (this.ended = !0), !1;
(0 !== i.avail_out && (0 !== i.avail_in || (4 !== n && 2 !== n))) ||
("string" === this.options.to
? this.onData(we.buf2binstring(a.shrinkBuf(i.output, i.next_out)))
: this.onData(a.shrinkBuf(i.output, i.next_out)));
} while ((i.avail_in > 0 || 0 === i.avail_out) && 1 !== r);
return 4 === n
? ((r = de.deflateEnd(this.strm)), this.onEnd(r), (this.ended = !0), r === me)
: 2 !== n || (this.onEnd(me), (i.avail_out = 0), !0);
}),
(ze.prototype.onData = function(t) {
this.chunks.push(t);
}),
(ze.prototype.onEnd = function(t) {
t === me &&
("string" === this.options.to
? (this.result = this.chunks.join(""))
: (this.result = a.flattenChunks(this.chunks))),
(this.chunks = []),
(this.err = t),
(this.msg = this.strm.msg);
});
var Be = {
Deflate: ze,
deflate: Ae,
deflateRaw: function(t, e) {
return ((e = e || {}).raw = !0), Ae(t, e);
},
gzip: function(t, e) {
return ((e = e || {}).gzip = !0), Ae(t, e);
}
},
Se = function(t, e) {
var a, r, n, i, s, o, l, h, f, d, u, _, c, g, b, w, p, v, m, k, y, x, z, A, B;
(a = t.state),
(r = t.next_in),
(A = t.input),
(n = r + (t.avail_in - 5)),
(i = t.next_out),
(B = t.output),
(s = i - (e - t.avail_out)),
(o = i + (t.avail_out - 257)),
(l = a.dmax),
(h = a.wsize),
(f = a.whave),
(d = a.wnext),
(u = a.window),
(_ = a.hold),
(c = a.bits),
(g = a.lencode),
(b = a.distcode),
(w = (1 << a.lenbits) - 1),
(p = (1 << a.distbits) - 1);
t: do {
c < 15 && ((_ += A[r++] << c), (c += 8), (_ += A[r++] << c), (c += 8)),
(v = g[_ & w]);
e: for (;;) {
if (((_ >>>= m = v >>> 24), (c -= m), 0 === (m = (v >>> 16) & 255)))
B[i++] = 65535 & v;
else {
if (!(16 & m)) {
if (0 == (64 & m)) {
v = g[(65535 & v) + (_ & ((1 << m) - 1))];
continue e;
}
if (32 & m) {
a.mode = 12;
break t;
}
(t.msg = "invalid literal/length code"), (a.mode = 30);
break t;
}
(k = 65535 & v),
(m &= 15) &&
(c < m && ((_ += A[r++] << c), (c += 8)),
(k += _ & ((1 << m) - 1)),
(_ >>>= m),
(c -= m)),
c < 15 && ((_ += A[r++] << c), (c += 8), (_ += A[r++] << c), (c += 8)),
(v = b[_ & p]);
a: for (;;) {
if (((_ >>>= m = v >>> 24), (c -= m), !(16 & (m = (v >>> 16) & 255)))) {
if (0 == (64 & m)) {
v = b[(65535 & v) + (_ & ((1 << m) - 1))];
continue a;
}
(t.msg = "invalid distance code"), (a.mode = 30);
break t;
}
if (
((y = 65535 & v),
c < (m &= 15) &&
((_ += A[r++] << c), (c += 8) < m && ((_ += A[r++] << c), (c += 8))),
(y += _ & ((1 << m) - 1)) > l)
) {
(t.msg = "invalid distance too far back"), (a.mode = 30);
break t;
}
if (((_ >>>= m), (c -= m), y > (m = i - s))) {
if ((m = y - m) > f && a.sane) {
(t.msg = "invalid distance too far back"), (a.mode = 30);
break t;
}
if (((x = 0), (z = u), 0 === d)) {
if (((x += h - m), m < k)) {
k -= m;
do {
B[i++] = u[x++];
} while (--m);
(x = i - y), (z = B);
}
} else if (d < m) {
if (((x += h + d - m), (m -= d) < k)) {
k -= m;
do {
B[i++] = u[x++];
} while (--m);
if (((x = 0), d < k)) {
k -= m = d;
do {
B[i++] = u[x++];
} while (--m);
(x = i - y), (z = B);
}
}
} else if (((x += d - m), m < k)) {
k -= m;
do {
B[i++] = u[x++];
} while (--m);
(x = i - y), (z = B);
}
for (; k > 2; )
(B[i++] = z[x++]), (B[i++] = z[x++]), (B[i++] = z[x++]), (k -= 3);
k && ((B[i++] = z[x++]), k > 1 && (B[i++] = z[x++]));
} else {
x = i - y;
do {
(B[i++] = B[x++]), (B[i++] = B[x++]), (B[i++] = B[x++]), (k -= 3);
} while (k > 2);
k && ((B[i++] = B[x++]), k > 1 && (B[i++] = B[x++]));
}
break;
}
}
break;
}
} while (r < n && i < o);
(r -= k = c >> 3),
(_ &= (1 << (c -= k << 3)) - 1),
(t.next_in = r),
(t.next_out = i),
(t.avail_in = r < n ? n - r + 5 : 5 - (r - n)),
(t.avail_out = i < o ? o - i + 257 : 257 - (i - o)),
(a.hold = _),
(a.bits = c);
},
Ue = [
3,
4,
5,
6,
7,
8,
9,
10,
11,
13,
15,
17,
19,
23,
27,
31,
35,
43,
51,
59,
67,
83,
99,
115,
131,
163,
195,
227,
258,
0,
0
],
Ee = [
16,
16,
16,
16,
16,
16,
16,
16,
17,
17,
17,
17,
18,
18,
18,
18,
19,
19,
19,
19,
20,
20,
20,
20,
21,
21,
21,
21,
16,
72,
78
],
Re = [
1,
2,
3,
4,
5,
7,
9,
13,
17,
25,
33,
49,
65,
97,
129,
193,
257,
385,
513,
769,
1025,
1537,
2049,
3073,
4097,
6145,
8193,
12289,
16385,
24577,
0,
0
],
Ie = [
16,
16,
16,
16,
17,
17,
18,
18,
19,
19,
20,
20,
21,
21,
22,
22,
23,
23,
24,
24,
25,
25,
26,
26,
27,
27,
28,
28,
29,
29,
64,
64
],
Ze = function(t, e, r, n, i, s, o, l) {
var h,
f,
d,
u,
_,
c,
g,
b,
w,
p = l.bits,
v = 0,
m = 0,
k = 0,
y = 0,
x = 0,
z = 0,
A = 0,
B = 0,
S = 0,
U = 0,
E = null,
R = 0,
I = new a.Buf16(16),
Z = new a.Buf16(16),
T = null,
N = 0;
for (v = 0; v <= 15; v++) I[v] = 0;
for (m = 0; m < n; m++) I[e[r + m]]++;
for (x = p, y = 15; y >= 1 && 0 === I[y]; y--);
if ((x > y && (x = y), 0 === y))
return (i[s++] = 20971520), (i[s++] = 20971520), (l.bits = 1), 0;
for (k = 1; k < y && 0 === I[k]; k++);
for (x < k && (x = k), B = 1, v = 1; v <= 15; v++)
if (((B <<= 1), (B -= I[v]) < 0)) return -1;
if (B > 0 && (0 === t || 1 !== y)) return -1;
for (Z[1] = 0, v = 1; v < 15; v++) Z[v + 1] = Z[v] + I[v];
for (m = 0; m < n; m++) 0 !== e[r + m] && (o[Z[e[r + m]]++] = m);
if (
(0 === t
? ((E = T = o), (c = 19))
: 1 === t
? ((E = Ue), (R -= 257), (T = Ee), (N -= 257), (c = 256))
: ((E = Re), (T = Ie), (c = -1)),
(U = 0),
(m = 0),
(v = k),
(_ = s),
(z = x),
(A = 0),
(d = -1),
(u = (S = 1 << x) - 1),
(1 === t && S > 852) || (2 === t && S > 592))
)
return 1;
for (;;) {
(g = v - A),
o[m] < c
? ((b = 0), (w = o[m]))
: o[m] > c
? ((b = T[N + o[m]]), (w = E[R + o[m]]))
: ((b = 96), (w = 0)),
(h = 1 << (v - A)),
(k = f = 1 << z);
do {
i[_ + (U >> A) + (f -= h)] = (g << 24) | (b << 16) | w | 0;
} while (0 !== f);
for (h = 1 << (v - 1); U & h; ) h >>= 1;
if ((0 !== h ? ((U &= h - 1), (U += h)) : (U = 0), m++, 0 == --I[v])) {
if (v === y) break;
v = e[r + o[m]];
}
if (v > x && (U & u) !== d) {
for (
0 === A && (A = x), _ += k, B = 1 << (z = v - A);
z + A < y && !((B -= I[z + A]) <= 0);

)
z++, (B <<= 1);
if (((S += 1 << z), (1 === t && S > 852) || (2 === t && S > 592))) return 1;
i[(d = U & u)] = (x << 24) | (z << 16) | (_ - s) | 0;
}
}
return (
0 !== U && (i[_ + U] = ((v - A) << 24) | (64 << 16) | 0), (l.bits = x), 0
);
},
Te = 0,
Ne = 1,
Ce = 2,
De = 4,
Me = 5,
Le = 6,
Oe = 0,
qe = 1,
Fe = 2,
He = -2,
Pe = -3,
je = -4,
Ge = -5,
Ke = 8,
Ye = 1,
Xe = 2,
Ve = 3,
We = 4,
Je = 5,
Qe = 6,
$e = 7,
ta = 8,
ea = 9,
aa = 10,
ra = 11,
na = 12,
ia = 13,
sa = 14,
oa = 15,
la = 16,
ha = 17,
fa = 18,
da = 19,
ua = 20,
_a = 21,
ca = 22,
ga = 23,
ba = 24,
wa = 25,
pa = 26,
va = 27,
ma = 28,
ka = 29,
ya = 30,
xa = 31,
za = 32,
Aa = 852,
Ba = 592,
Sa = 15;
function Ua(t) {
return (
((t >>> 24) & 255) +
((t >>> 8) & 65280) +
((65280 & t) << 8) +
((255 & t) << 24)
);
}
function Ea() {
(this.mode = 0),
(this.last = !1),
(this.wrap = 0),
(this.havedict = !1),
(this.flags = 0),
(this.dmax = 0),
(this.check = 0),
(this.total = 0),
(this.head = null),
(this.wbits = 0),
(this.wsize = 0),
(this.whave = 0),
(this.wnext = 0),
(this.window = null),
(this.hold = 0),
(this.bits = 0),
(this.length = 0),
(this.offset = 0),
(this.extra = 0),
(this.lencode = null),
(this.distcode = null),
(this.lenbits = 0),
(this.distbits = 0),
(this.ncode = 0),
(this.nlen = 0),
(this.ndist = 0),
(this.have = 0),
(this.next = null),
(this.lens = new a.Buf16(320)),
(this.work = new a.Buf16(288)),
(this.lendyn = null),
(this.distdyn = null),
(this.sane = 0),
(this.back = 0),
(this.was = 0);
}
function Ra(t) {
var e;
return t && t.state
? ((e = t.state),
  (t.total_in = t.total_out = e.total = 0),
  (t.msg = ""),
  e.wrap && (t.adler = 1 & e.wrap),
  (e.mode = Ye),
  (e.last = 0),
  (e.havedict = 0),
  (e.dmax = 32768),
  (e.head = null),
  (e.hold = 0),
  (e.bits = 0),
  (e.lencode = e.lendyn = new a.Buf32(Aa)),
  (e.distcode = e.distdyn = new a.Buf32(Ba)),
  (e.sane = 1),
  (e.back = -1),
  Oe)
: He;
}
function Ia(t) {
var e;
return t && t.state
? (((e = t.state).wsize = 0), (e.whave = 0), (e.wnext = 0), Ra(t))
: He;
}
function Za(t, e) {
var a, r;
return t && t.state
? ((r = t.state),
  e < 0 ? ((a = 0), (e = -e)) : ((a = 1 + (e >> 4)), e < 48 && (e &= 15)),
  e && (e < 8 || e > 15)
  ? He
  : (null !== r.window && r.wbits !== e && (r.window = null),
    (r.wrap = a),
    (r.wbits = e),
    Ia(t)))
: He;
}
function Ta(t, e) {
var a, r;
return t
? ((r = new Ea()),
  (t.state = r),
  (r.window = null),
  (a = Za(t, e)) !== Oe && (t.state = null),
  a)
: He;
}
var Na,
Ca,
Da = !0;
function Ma(t) {
if (Da) {
var e;
for (Na = new a.Buf32(512), Ca = new a.Buf32(32), e = 0; e < 144; )
t.lens[e++] = 8;
for (; e < 256; ) t.lens[e++] = 9;
for (; e < 280; ) t.lens[e++] = 7;
for (; e < 288; ) t.lens[e++] = 8;
for (Ze(Ne, t.lens, 0, 288, Na, 0, t.work, {bits: 9}), e = 0; e < 32; )
t.lens[e++] = 5;
Ze(Ce, t.lens, 0, 32, Ca, 0, t.work, {bits: 5}), (Da = !1);
}
(t.lencode = Na), (t.lenbits = 9), (t.distcode = Ca), (t.distbits = 5);
}
function La(t, e, r, n) {
var i,
s = t.state;
return (
null === s.window &&
((s.wsize = 1 << s.wbits),
(s.wnext = 0),
(s.whave = 0),
(s.window = new a.Buf8(s.wsize))),
n >= s.wsize
? (a.arraySet(s.window, e, r - s.wsize, s.wsize, 0),
  (s.wnext = 0),
  (s.whave = s.wsize))
: ((i = s.wsize - s.wnext) > n && (i = n),
  a.arraySet(s.window, e, r - n, i, s.wnext),
  (n -= i)
  ? (a.arraySet(s.window, e, r - n, n, 0), (s.wnext = n), (s.whave = s.wsize))
  : ((s.wnext += i),
    s.wnext === s.wsize && (s.wnext = 0),
    s.whave < s.wsize && (s.whave += i))),
0
);
}
var Oa = {
inflateReset: Ia,
inflateReset2: Za,
inflateResetKeep: Ra,
inflateInit: function(t) {
return Ta(t, Sa);
},
inflateInit2: Ta,
inflate: function(t, e) {
var r,
n,
i,
s,
o,
l,
h,
f,
d,
u,
_,
c,
g,
b,
w,
p,
v,
m,
k,
y,
x,
z,
A,
B,
S = 0,
U = new a.Buf8(4),
E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
if (!t || !t.state || !t.output || (!t.input && 0 !== t.avail_in)) return He;
(r = t.state).mode === na && (r.mode = ia),
(o = t.next_out),
(i = t.output),
(h = t.avail_out),
(s = t.next_in),
(n = t.input),
(l = t.avail_in),
(f = r.hold),
(d = r.bits),
(u = l),
(_ = h),
(z = Oe);
t: for (;;)
switch (r.mode) {
case Ye:
if (0 === r.wrap) {
r.mode = ia;
break;
}
for (; d < 16; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (2 & r.wrap && 35615 === f) {
(r.check = 0),
(U[0] = 255 & f),
(U[1] = (f >>> 8) & 255),
(r.check = it(r.check, U, 2, 0)),
(f = 0),
(d = 0),
(r.mode = Xe);
break;
}
if (
((r.flags = 0),
r.head && (r.head.done = !1),
!(1 & r.wrap) || (((255 & f) << 8) + (f >> 8)) % 31)
) {
(t.msg = "incorrect header check"), (r.mode = ya);
break;
}
if ((15 & f) !== Ke) {
(t.msg = "unknown compression method"), (r.mode = ya);
break;
}
if (((d -= 4), (x = 8 + (15 & (f >>>= 4))), 0 === r.wbits)) r.wbits = x;
else if (x > r.wbits) {
(t.msg = "invalid window size"), (r.mode = ya);
break;
}
(r.dmax = 1 << x),
(t.adler = r.check = 1),
(r.mode = 512 & f ? aa : na),
(f = 0),
(d = 0);
break;
case Xe:
for (; d < 16; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (((r.flags = f), (255 & r.flags) !== Ke)) {
(t.msg = "unknown compression method"), (r.mode = ya);
break;
}
if (57344 & r.flags) {
(t.msg = "unknown header flags set"), (r.mode = ya);
break;
}
r.head && (r.head.text = (f >> 8) & 1),
512 & r.flags &&
((U[0] = 255 & f), (U[1] = (f >>> 8) & 255), (r.check = it(r.check, U, 2, 0))),
(f = 0),
(d = 0),
(r.mode = Ve);
case Ve:
for (; d < 32; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
r.head && (r.head.time = f),
512 & r.flags &&
((U[0] = 255 & f),
(U[1] = (f >>> 8) & 255),
(U[2] = (f >>> 16) & 255),
(U[3] = (f >>> 24) & 255),
(r.check = it(r.check, U, 4, 0))),
(f = 0),
(d = 0),
(r.mode = We);
case We:
for (; d < 16; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
r.head && ((r.head.xflags = 255 & f), (r.head.os = f >> 8)),
512 & r.flags &&
((U[0] = 255 & f), (U[1] = (f >>> 8) & 255), (r.check = it(r.check, U, 2, 0))),
(f = 0),
(d = 0),
(r.mode = Je);
case Je:
if (1024 & r.flags) {
for (; d < 16; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(r.length = f),
r.head && (r.head.extra_len = f),
512 & r.flags &&
((U[0] = 255 & f), (U[1] = (f >>> 8) & 255), (r.check = it(r.check, U, 2, 0))),
(f = 0),
(d = 0);
} else r.head && (r.head.extra = null);
r.mode = Qe;
case Qe:
if (
1024 & r.flags &&
((c = r.length) > l && (c = l),
c &&
(r.head &&
((x = r.head.extra_len - r.length),
r.head.extra || (r.head.extra = new Array(r.head.extra_len)),
a.arraySet(r.head.extra, n, s, c, x)),
512 & r.flags && (r.check = it(r.check, n, c, s)),
(l -= c),
(s += c),
(r.length -= c)),
r.length)
)
break t;
(r.length = 0), (r.mode = $e);
case $e:
if (2048 & r.flags) {
if (0 === l) break t;
c = 0;
do {
(x = n[s + c++]),
r.head && x && r.length < 65536 && (r.head.name += String.fromCharCode(x));
} while (x && c < l);
if ((512 & r.flags && (r.check = it(r.check, n, c, s)), (l -= c), (s += c), x))
break t;
} else r.head && (r.head.name = null);
(r.length = 0), (r.mode = ta);
case ta:
if (4096 & r.flags) {
if (0 === l) break t;
c = 0;
do {
(x = n[s + c++]),
r.head && x && r.length < 65536 && (r.head.comment += String.fromCharCode(x));
} while (x && c < l);
if ((512 & r.flags && (r.check = it(r.check, n, c, s)), (l -= c), (s += c), x))
break t;
} else r.head && (r.head.comment = null);
r.mode = ea;
case ea:
if (512 & r.flags) {
for (; d < 16; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (f !== (65535 & r.check)) {
(t.msg = "header crc mismatch"), (r.mode = ya);
break;
}
(f = 0), (d = 0);
}
r.head && ((r.head.hcrc = (r.flags >> 9) & 1), (r.head.done = !0)),
(t.adler = r.check = 0),
(r.mode = na);
break;
case aa:
for (; d < 32; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(t.adler = r.check = Ua(f)), (f = 0), (d = 0), (r.mode = ra);
case ra:
if (0 === r.havedict)
return (
(t.next_out = o),
(t.avail_out = h),
(t.next_in = s),
(t.avail_in = l),
(r.hold = f),
(r.bits = d),
Fe
);
(t.adler = r.check = 1), (r.mode = na);
case na:
if (e === Me || e === Le) break t;
case ia:
if (r.last) {
(f >>>= 7 & d), (d -= 7 & d), (r.mode = va);
break;
}
for (; d < 3; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
switch (((r.last = 1 & f), (d -= 1), 3 & (f >>>= 1))) {
case 0:
r.mode = sa;
break;
case 1:
if ((Ma(r), (r.mode = ua), e === Le)) {
(f >>>= 2), (d -= 2);
break t;
}
break;
case 2:
r.mode = ha;
break;
case 3:
(t.msg = "invalid block type"), (r.mode = ya);
}
(f >>>= 2), (d -= 2);
break;
case sa:
for (f >>>= 7 & d, d -= 7 & d; d < 32; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if ((65535 & f) != ((f >>> 16) ^ 65535)) {
(t.msg = "invalid stored block lengths"), (r.mode = ya);
break;
}
if (((r.length = 65535 & f), (f = 0), (d = 0), (r.mode = oa), e === Le))
break t;
case oa:
r.mode = la;
case la:
if ((c = r.length)) {
if ((c > l && (c = l), c > h && (c = h), 0 === c)) break t;
a.arraySet(i, n, s, c, o),
(l -= c),
(s += c),
(h -= c),
(o += c),
(r.length -= c);
break;
}
r.mode = na;
break;
case ha:
for (; d < 14; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (
((r.nlen = 257 + (31 & f)),
(f >>>= 5),
(d -= 5),
(r.ndist = 1 + (31 & f)),
(f >>>= 5),
(d -= 5),
(r.ncode = 4 + (15 & f)),
(f >>>= 4),
(d -= 4),
r.nlen > 286 || r.ndist > 30)
) {
(t.msg = "too many length or distance symbols"), (r.mode = ya);
break;
}
(r.have = 0), (r.mode = fa);
case fa:
for (; r.have < r.ncode; ) {
for (; d < 3; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(r.lens[E[r.have++]] = 7 & f), (f >>>= 3), (d -= 3);
}
for (; r.have < 19; ) r.lens[E[r.have++]] = 0;
if (
((r.lencode = r.lendyn),
(r.lenbits = 7),
(A = {bits: r.lenbits}),
(z = Ze(Te, r.lens, 0, 19, r.lencode, 0, r.work, A)),
(r.lenbits = A.bits),
z)
) {
(t.msg = "invalid code lengths set"), (r.mode = ya);
break;
}
(r.have = 0), (r.mode = da);
case da:
for (; r.have < r.nlen + r.ndist; ) {
for (
;
(p = ((S = r.lencode[f & ((1 << r.lenbits) - 1)]) >>> 16) & 255),
(v = 65535 & S),
!((w = S >>> 24) <= d);

) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (v < 16) (f >>>= w), (d -= w), (r.lens[r.have++] = v);
else {
if (16 === v) {
for (B = w + 2; d < B; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (((f >>>= w), (d -= w), 0 === r.have)) {
(t.msg = "invalid bit length repeat"), (r.mode = ya);
break;
}
(x = r.lens[r.have - 1]), (c = 3 + (3 & f)), (f >>>= 2), (d -= 2);
} else if (17 === v) {
for (B = w + 3; d < B; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(d -= w), (x = 0), (c = 3 + (7 & (f >>>= w))), (f >>>= 3), (d -= 3);
} else {
for (B = w + 7; d < B; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(d -= w), (x = 0), (c = 11 + (127 & (f >>>= w))), (f >>>= 7), (d -= 7);
}
if (r.have + c > r.nlen + r.ndist) {
(t.msg = "invalid bit length repeat"), (r.mode = ya);
break;
}
for (; c--; ) r.lens[r.have++] = x;
}
}
if (r.mode === ya) break;
if (0 === r.lens[256]) {
(t.msg = "invalid code -- missing end-of-block"), (r.mode = ya);
break;
}
if (
((r.lenbits = 9),
(A = {bits: r.lenbits}),
(z = Ze(Ne, r.lens, 0, r.nlen, r.lencode, 0, r.work, A)),
(r.lenbits = A.bits),
z)
) {
(t.msg = "invalid literal/lengths set"), (r.mode = ya);
break;
}
if (
((r.distbits = 6),
(r.distcode = r.distdyn),
(A = {bits: r.distbits}),
(z = Ze(Ce, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, A)),
(r.distbits = A.bits),
z)
) {
(t.msg = "invalid distances set"), (r.mode = ya);
break;
}
if (((r.mode = ua), e === Le)) break t;
case ua:
r.mode = _a;
case _a:
if (l >= 6 && h >= 258) {
(t.next_out = o),
(t.avail_out = h),
(t.next_in = s),
(t.avail_in = l),
(r.hold = f),
(r.bits = d),
Se(t, _),
(o = t.next_out),
(i = t.output),
(h = t.avail_out),
(s = t.next_in),
(n = t.input),
(l = t.avail_in),
(f = r.hold),
(d = r.bits),
r.mode === na && (r.back = -1);
break;
}
for (
r.back = 0;
(p = ((S = r.lencode[f & ((1 << r.lenbits) - 1)]) >>> 16) & 255),
(v = 65535 & S),
!((w = S >>> 24) <= d);

) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (p && 0 == (240 & p)) {
for (
m = w, k = p, y = v;
(p = ((S = r.lencode[y + ((f & ((1 << (m + k)) - 1)) >> m)]) >>> 16) & 255),
(v = 65535 & S),
!(m + (w = S >>> 24) <= d);

) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(f >>>= m), (d -= m), (r.back += m);
}
if (((f >>>= w), (d -= w), (r.back += w), (r.length = v), 0 === p)) {
r.mode = pa;
break;
}
if (32 & p) {
(r.back = -1), (r.mode = na);
break;
}
if (64 & p) {
(t.msg = "invalid literal/length code"), (r.mode = ya);
break;
}
(r.extra = 15 & p), (r.mode = ca);
case ca:
if (r.extra) {
for (B = r.extra; d < B; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(r.length += f & ((1 << r.extra) - 1)),
(f >>>= r.extra),
(d -= r.extra),
(r.back += r.extra);
}
(r.was = r.length), (r.mode = ga);
case ga:
for (
;
(p = ((S = r.distcode[f & ((1 << r.distbits) - 1)]) >>> 16) & 255),
(v = 65535 & S),
!((w = S >>> 24) <= d);

) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (0 == (240 & p)) {
for (
m = w, k = p, y = v;
(p = ((S = r.distcode[y + ((f & ((1 << (m + k)) - 1)) >> m)]) >>> 16) & 255),
(v = 65535 & S),
!(m + (w = S >>> 24) <= d);

) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(f >>>= m), (d -= m), (r.back += m);
}
if (((f >>>= w), (d -= w), (r.back += w), 64 & p)) {
(t.msg = "invalid distance code"), (r.mode = ya);
break;
}
(r.offset = v), (r.extra = 15 & p), (r.mode = ba);
case ba:
if (r.extra) {
for (B = r.extra; d < B; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
(r.offset += f & ((1 << r.extra) - 1)),
(f >>>= r.extra),
(d -= r.extra),
(r.back += r.extra);
}
if (r.offset > r.dmax) {
(t.msg = "invalid distance too far back"), (r.mode = ya);
break;
}
r.mode = wa;
case wa:
if (0 === h) break t;
if (((c = _ - h), r.offset > c)) {
if ((c = r.offset - c) > r.whave && r.sane) {
(t.msg = "invalid distance too far back"), (r.mode = ya);
break;
}
c > r.wnext ? ((c -= r.wnext), (g = r.wsize - c)) : (g = r.wnext - c),
c > r.length && (c = r.length),
(b = r.window);
} else (b = i), (g = o - r.offset), (c = r.length);
c > h && (c = h), (h -= c), (r.length -= c);
do {
i[o++] = b[g++];
} while (--c);
0 === r.length && (r.mode = _a);
break;
case pa:
if (0 === h) break t;
(i[o++] = r.length), h--, (r.mode = _a);
break;
case va:
if (r.wrap) {
for (; d < 32; ) {
if (0 === l) break t;
l--, (f |= n[s++] << d), (d += 8);
}
if (
((_ -= h),
(t.total_out += _),
(r.total += _),
_ &&
(t.adler = r.check = r.flags
? it(r.check, i, _, o - _)
: at(r.check, i, _, o - _)),
(_ = h),
(r.flags ? f : Ua(f)) !== r.check)
) {
(t.msg = "incorrect data check"), (r.mode = ya);
break;
}
(f = 0), (d = 0);
}
r.mode = ma;
case ma:
if (r.wrap && r.flags) {
for (; d < 32; ) {
if (0 === l) break t;
l--, (f += n[s++] << d), (d += 8);
}
if (f !== (4294967295 & r.total)) {
(t.msg = "incorrect length check"), (r.mode = ya);
break;
}
(f = 0), (d = 0);
}
r.mode = ka;
case ka:
z = qe;
break t;
case ya:
z = Pe;
break t;
case xa:
return je;
case za:
default:
return He;
}
return (
(t.next_out = o),
(t.avail_out = h),
(t.next_in = s),
(t.avail_in = l),
(r.hold = f),
(r.bits = d),
(r.wsize || (_ !== t.avail_out && r.mode < ya && (r.mode < va || e !== De))) &&
La(t, t.output, t.next_out, _ - t.avail_out),
(u -= t.avail_in),
(_ -= t.avail_out),
(t.total_in += u),
(t.total_out += _),
(r.total += _),
r.wrap &&
_ &&
(t.adler = r.check = r.flags
? it(r.check, i, _, t.next_out - _)
: at(r.check, i, _, t.next_out - _)),
(t.data_type =
r.bits +
(r.last ? 64 : 0) +
(r.mode === na ? 128 : 0) +
(r.mode === ua || r.mode === oa ? 256 : 0)),
((0 === u && 0 === _) || e === De) && z === Oe && (z = Ge),
z
);
},
inflateEnd: function(t) {
if (!t || !t.state) return He;
var e = t.state;
return e.window && (e.window = null), (t.state = null), Oe;
},
inflateGetHeader: function(t, e) {
var a;
return t && t.state
? 0 == (2 & (a = t.state).wrap)
  ? He
  : ((a.head = e), (e.done = !1), Oe)
: He;
},
inflateSetDictionary: function(t, e) {
var a,
r = e.length;
return t && t.state
? 0 !== (a = t.state).wrap && a.mode !== ra
  ? He
  : a.mode === ra && at(1, e, r, 0) !== a.check
  ? Pe
  : La(t, e, r, r)
  ? ((a.mode = xa), je)
  : ((a.havedict = 1), Oe)
: He;
},
inflateInfo: "pako inflate (from Nodeca project)"
},
qa = {
Z_NO_FLUSH: 0,
Z_PARTIAL_FLUSH: 1,
Z_SYNC_FLUSH: 2,
Z_FULL_FLUSH: 3,
Z_FINISH: 4,
Z_BLOCK: 5,
Z_TREES: 6,
Z_OK: 0,
Z_STREAM_END: 1,
Z_NEED_DICT: 2,
Z_ERRNO: -1,
Z_STREAM_ERROR: -2,
Z_DATA_ERROR: -3,
Z_BUF_ERROR: -5,
Z_NO_COMPRESSION: 0,
Z_BEST_SPEED: 1,
Z_BEST_COMPRESSION: 9,
Z_DEFAULT_COMPRESSION: -1,
Z_FILTERED: 1,
Z_HUFFMAN_ONLY: 2,
Z_RLE: 3,
Z_FIXED: 4,
Z_DEFAULT_STRATEGY: 0,
Z_BINARY: 0,
Z_TEXT: 1,
Z_UNKNOWN: 2,
Z_DEFLATED: 8
};
var Fa = function() {
(this.text = 0),
(this.time = 0),
(this.xflags = 0),
(this.os = 0),
(this.extra = null),
(this.extra_len = 0),
(this.name = ""),
(this.comment = ""),
(this.hcrc = 0),
(this.done = !1);
},
Ha = Object.prototype.toString;
function Pa(t) {
if (!(this instanceof Pa)) return new Pa(t);
this.options = a.assign({chunkSize: 16384, windowBits: 0, to: ""}, t || {});
var e = this.options;
e.raw &&
e.windowBits >= 0 &&
e.windowBits < 16 &&
((e.windowBits = -e.windowBits), 0 === e.windowBits && (e.windowBits = -15)),
!(e.windowBits >= 0 && e.windowBits < 16) ||
(t && t.windowBits) ||
(e.windowBits += 32),
e.windowBits > 15 &&
e.windowBits < 48 &&
0 == (15 & e.windowBits) &&
(e.windowBits |= 15),
(this.err = 0),
(this.msg = ""),
(this.ended = !1),
(this.chunks = []),
(this.strm = new pe()),
(this.strm.avail_out = 0);
var r = Oa.inflateInit2(this.strm, e.windowBits);
if (r !== qa.Z_OK) throw new Error(st[r]);
if (
((this.header = new Fa()),
Oa.inflateGetHeader(this.strm, this.header),
e.dictionary &&
("string" == typeof e.dictionary
? (e.dictionary = we.string2buf(e.dictionary))
: "[object ArrayBuffer]" === Ha.call(e.dictionary) &&
  (e.dictionary = new Uint8Array(e.dictionary)),
e.raw && (r = Oa.inflateSetDictionary(this.strm, e.dictionary)) !== qa.Z_OK))
)
throw new Error(st[r]);
}
function ja(t, e) {
var a = new Pa(e);
if ((a.push(t, !0), a.err)) throw a.msg || st[a.err];
return a.result;
}
(Pa.prototype.push = function(t, e) {
var r,
n,
i,
s,
o,
l = this.strm,
h = this.options.chunkSize,
f = this.options.dictionary,
d = !1;
if (this.ended) return !1;
(n = e === ~~e ? e : !0 === e ? qa.Z_FINISH : qa.Z_NO_FLUSH),
"string" == typeof t
? (l.input = we.binstring2buf(t))
: "[object ArrayBuffer]" === Ha.call(t)
? (l.input = new Uint8Array(t))
: (l.input = t),
(l.next_in = 0),
(l.avail_in = l.input.length);
do {
if (
(0 === l.avail_out &&
((l.output = new a.Buf8(h)), (l.next_out = 0), (l.avail_out = h)),
(r = Oa.inflate(l, qa.Z_NO_FLUSH)) === qa.Z_NEED_DICT &&
f &&
(r = Oa.inflateSetDictionary(this.strm, f)),
r === qa.Z_BUF_ERROR && !0 === d && ((r = qa.Z_OK), (d = !1)),
r !== qa.Z_STREAM_END && r !== qa.Z_OK)
)
return this.onEnd(r), (this.ended = !0), !1;
l.next_out &&
((0 !== l.avail_out &&
r !== qa.Z_STREAM_END &&
(0 !== l.avail_in || (n !== qa.Z_FINISH && n !== qa.Z_SYNC_FLUSH))) ||
("string" === this.options.to
? ((i = we.utf8border(l.output, l.next_out)),
  (s = l.next_out - i),
  (o = we.buf2string(l.output, i)),
  (l.next_out = s),
  (l.avail_out = h - s),
  s && a.arraySet(l.output, l.output, i, s, 0),
  this.onData(o))
: this.onData(a.shrinkBuf(l.output, l.next_out)))),
0 === l.avail_in && 0 === l.avail_out && (d = !0);
} while ((l.avail_in > 0 || 0 === l.avail_out) && r !== qa.Z_STREAM_END);
return (
r === qa.Z_STREAM_END && (n = qa.Z_FINISH),
n === qa.Z_FINISH
? ((r = Oa.inflateEnd(this.strm)),
  this.onEnd(r),
  (this.ended = !0),
  r === qa.Z_OK)
: n !== qa.Z_SYNC_FLUSH || (this.onEnd(qa.Z_OK), (l.avail_out = 0), !0)
);
}),
(Pa.prototype.onData = function(t) {
this.chunks.push(t);
}),
(Pa.prototype.onEnd = function(t) {
t === qa.Z_OK &&
("string" === this.options.to
? (this.result = this.chunks.join(""))
: (this.result = a.flattenChunks(this.chunks))),
(this.chunks = []),
(this.err = t),
(this.msg = this.strm.msg);
});
var Ga = {
Inflate: Pa,
inflate: ja,
inflateRaw: function(t, e) {
return ((e = e || {}).raw = !0), ja(t, e);
},
ungzip: ja
},
Ka = {};
(0, a.assign)(Ka, Be, Ga, qa);
var Ya = Ka,
Xa = e(function(t) {
var e;
(e = {}),
(t.exports = e),
(function(t, e) {
(t.toRGBA8 = function(e) {
var a = e.width,
r = e.height;
if (null == e.tabs.acTL) return [t.toRGBA8.decodeImage(e.data, a, r, e).buffer];
var n = [];
null == e.frames[0].data && (e.frames[0].data = e.data);
for (var i, s = new Uint8Array(a * r * 4), o = 0; o < e.frames.length; o++) {
var l = e.frames[o],
h = l.rect.x,
f = l.rect.y,
d = l.rect.width,
u = l.rect.height,
_ = t.toRGBA8.decodeImage(l.data, d, u, e);
if (
(0 == o
? (i = _)
: 0 == l.blend
? t._copyTile(_, d, u, i, a, r, h, f, 0)
: 1 == l.blend && t._copyTile(_, d, u, i, a, r, h, f, 1),
n.push(i.buffer),
(i = i.slice(0)),
0 == l.dispose)
);
else if (1 == l.dispose) t._copyTile(s, d, u, i, a, r, h, f, 0);
else if (2 == l.dispose) {
for (var c = o - 1; 2 == e.frames[c].dispose; ) c--;
i = new Uint8Array(n[c]).slice(0);
}
}
return n;
}),
(t.toRGBA8.decodeImage = function(e, a, r, n) {
var i = a * r,
s = t.decode._getBPP(n),
o = Math.ceil((a * s) / 8),
l = new Uint8Array(4 * i),
h = new Uint32Array(l.buffer),
f = n.ctype,
d = n.depth,
u = t._bin.readUshort;
if (6 == f) {
var _ = i << 2;
if (8 == d) for (var c = 0; c < _; c++) l[c] = e[c];
if (16 == d) for (c = 0; c < _; c++) l[c] = e[c << 1];
} else if (2 == f) {
var g = n.tabs.tRNS,
b = -1,
w = -1,
p = -1;
if ((g && ((b = g[0]), (w = g[1]), (p = g[2])), 8 == d))
for (c = 0; c < i; c++) {
var v = 3 * c;
(l[(B = c << 2)] = e[v]),
(l[B + 1] = e[v + 1]),
(l[B + 2] = e[v + 2]),
(l[B + 3] = 255),
-1 != b && e[v] == b && e[v + 1] == w && e[v + 2] == p && (l[B + 3] = 0);
}
if (16 == d)
for (c = 0; c < i; c++)
(v = 6 * c),
(l[(B = c << 2)] = e[v]),
(l[B + 1] = e[v + 2]),
(l[B + 2] = e[v + 4]),
(l[B + 3] = 255),
-1 != b &&
u(e, v) == b &&
u(e, v + 2) == w &&
u(e, v + 4) == p &&
(l[B + 3] = 0);
} else if (3 == f) {
var m = n.tabs.PLTE,
k = n.tabs.tRNS,
y = k ? k.length : 0;
if (1 == d)
for (var x = 0; x < r; x++) {
var z = x * o,
A = x * a;
for (c = 0; c < a; c++) {
var B = (A + c) << 2,
S = 3 * (U = (e[z + (c >> 3)] >> (7 - ((7 & c) << 0))) & 1);
(l[B] = m[S]),
(l[B + 1] = m[S + 1]),
(l[B + 2] = m[S + 2]),
(l[B + 3] = U < y ? k[U] : 255);
}
}
if (2 == d)
for (x = 0; x < r; x++)
for (z = x * o, A = x * a, c = 0; c < a; c++)
(B = (A + c) << 2),
(S = 3 * (U = (e[z + (c >> 2)] >> (6 - ((3 & c) << 1))) & 3)),
(l[B] = m[S]),
(l[B + 1] = m[S + 1]),
(l[B + 2] = m[S + 2]),
(l[B + 3] = U < y ? k[U] : 255);
if (4 == d)
for (x = 0; x < r; x++)
for (z = x * o, A = x * a, c = 0; c < a; c++)
(B = (A + c) << 2),
(S = 3 * (U = (e[z + (c >> 1)] >> (4 - ((1 & c) << 2))) & 15)),
(l[B] = m[S]),
(l[B + 1] = m[S + 1]),
(l[B + 2] = m[S + 2]),
(l[B + 3] = U < y ? k[U] : 255);
if (8 == d)
for (c = 0; c < i; c++) {
var U;
(B = c << 2),
(S = 3 * (U = e[c])),
(l[B] = m[S]),
(l[B + 1] = m[S + 1]),
(l[B + 2] = m[S + 2]),
(l[B + 3] = U < y ? k[U] : 255);
}
} else if (4 == f) {
if (8 == d)
for (c = 0; c < i; c++) {
B = c << 2;
var E = e[(R = c << 1)];
(l[B] = E), (l[B + 1] = E), (l[B + 2] = E), (l[B + 3] = e[R + 1]);
}
if (16 == d)
for (c = 0; c < i; c++) {
var R;
(B = c << 2),
(E = e[(R = c << 2)]),
(l[B] = E),
(l[B + 1] = E),
(l[B + 2] = E),
(l[B + 3] = e[R + 2]);
}
} else if (0 == f) {
if (((b = n.tabs.tRNS ? n.tabs.tRNS : -1), 1 == d))
for (c = 0; c < i; c++) {
var I = (E = 255 * ((e[c >> 3] >> (7 - (7 & c))) & 1)) == 255 * b ? 0 : 255;
h[c] = (I << 24) | (E << 16) | (E << 8) | E;
}
if (2 == d)
for (c = 0; c < i; c++)
(I = (E = 85 * ((e[c >> 2] >> (6 - ((3 & c) << 1))) & 3)) == 85 * b ? 0 : 255),
(h[c] = (I << 24) | (E << 16) | (E << 8) | E);
if (4 == d)
for (c = 0; c < i; c++)
(I = (E = 17 * ((e[c >> 1] >> (4 - ((1 & c) << 2))) & 15)) == 17 * b ? 0 : 255),
(h[c] = (I << 24) | (E << 16) | (E << 8) | E);
if (8 == d)
for (c = 0; c < i; c++)
(I = (E = e[c]) == b ? 0 : 255), (h[c] = (I << 24) | (E << 16) | (E << 8) | E);
if (16 == d)
for (c = 0; c < i; c++)
(E = e[c << 1]),
(I = u(e, c << 1) == b ? 0 : 255),
(h[c] = (I << 24) | (E << 16) | (E << 8) | E);
}
return l;
}),
(t.decode = function(e) {
for (
var a,
r = new Uint8Array(e),
n = 8,
i = t._bin,
s = i.readUshort,
o = i.readUint,
l = {tabs: {}, frames: []},
h = new Uint8Array(r.length),
f = 0,
d = 0,
u = [137, 80, 78, 71, 13, 10, 26, 10],
_ = 0;
_ < 8;
_++
)
if (r[_] != u[_]) throw "The input is not a PNG file!";
for (; n < r.length; ) {
var c = i.readUint(r, n);
n += 4;
var g = i.readASCII(r, n, 4);
if (((n += 4), "IHDR" == g)) t.decode._IHDR(r, n, l);
else if ("IDAT" == g) {
for (_ = 0; _ < c; _++) h[f + _] = r[n + _];
f += c;
} else if ("acTL" == g)
(l.tabs[g] = {num_frames: o(r, n), num_plays: o(r, n + 4)}),
(a = new Uint8Array(r.length));
else if ("fcTL" == g) {
0 != d &&
(((z = l.frames[l.frames.length - 1]).data = t.decode._decompress(
l,
a.slice(0, d),
z.rect.width,
z.rect.height
)),
(d = 0));
var b = {
x: o(r, n + 12),
y: o(r, n + 16),
width: o(r, n + 4),
height: o(r, n + 8)
},
w = s(r, n + 22);
w = s(r, n + 20) / (0 == w ? 100 : w);
var p = {
rect: b,
delay: Math.round(1e3 * w),
dispose: r[n + 24],
blend: r[n + 25]
};
l.frames.push(p);
} else if ("fdAT" == g) {
for (_ = 0; _ < c - 4; _++) a[d + _] = r[n + _ + 4];
d += c - 4;
} else if ("pHYs" == g)
l.tabs[g] = [i.readUint(r, n), i.readUint(r, n + 4), r[n + 8]];
else if ("cHRM" == g)
for (l.tabs[g] = [], _ = 0; _ < 8; _++)
l.tabs[g].push(i.readUint(r, n + 4 * _));
else if ("tEXt" == g) {
null == l.tabs[g] && (l.tabs[g] = {});
var v = i.nextZero(r, n),
m = i.readASCII(r, n, v - n),
k = i.readASCII(r, v + 1, n + c - v - 1);
l.tabs[g][m] = k;
} else if ("iTXt" == g) {
null == l.tabs[g] && (l.tabs[g] = {}), (v = 0);
var y = n;
(v = i.nextZero(r, y)),
(m = i.readASCII(r, y, v - y)),
(y = v + 1),
(y += 2),
(v = i.nextZero(r, y)),
i.readASCII(r, y, v - y),
(y = v + 1),
(v = i.nextZero(r, y)),
i.readUTF8(r, y, v - y),
(y = v + 1),
(k = i.readUTF8(r, y, c - (y - n))),
(l.tabs[g][m] = k);
} else if ("PLTE" == g) l.tabs[g] = i.readBytes(r, n, c);
else if ("hIST" == g) {
var x = l.tabs.PLTE.length / 3;
for (l.tabs[g] = [], _ = 0; _ < x; _++) l.tabs[g].push(s(r, n + 2 * _));
} else if ("tRNS" == g)
3 == l.ctype
? (l.tabs[g] = i.readBytes(r, n, c))
: 0 == l.ctype
? (l.tabs[g] = s(r, n))
: 2 == l.ctype && (l.tabs[g] = [s(r, n), s(r, n + 2), s(r, n + 4)]);
else if ("gAMA" == g) l.tabs[g] = i.readUint(r, n) / 1e5;
else if ("sRGB" == g) l.tabs[g] = r[n];
else if ("bKGD" == g)
0 == l.ctype || 4 == l.ctype
? (l.tabs[g] = [s(r, n)])
: 2 == l.ctype || 6 == l.ctype
? (l.tabs[g] = [s(r, n), s(r, n + 2), s(r, n + 4)])
: 3 == l.ctype && (l.tabs[g] = r[n]);
else if ("IEND" == g) {
var z;
0 != d &&
(((z = l.frames[l.frames.length - 1]).data = t.decode._decompress(
l,
a.slice(0, d),
z.rect.width,
z.rect.height
)),
(d = 0)),
(l.data = t.decode._decompress(l, h, l.width, l.height));
break;
}
(n += c), i.readUint(r, n), (n += 4);
}
return delete l.compress, delete l.interlace, delete l.filter, l;
}),
(t.decode._decompress = function(e, a, r, n) {
return (
0 == e.compress && (a = t.decode._inflate(a)),
0 == e.interlace
? (a = t.decode._filterZero(a, e, 0, r, n))
: 1 == e.interlace && (a = t.decode._readInterlace(a, e)),
a
);
}),
(t.decode._inflate = function(t) {
return e.inflate(t);
}),
(t.decode._readInterlace = function(e, a) {
for (
var r = a.width,
n = a.height,
i = t.decode._getBPP(a),
s = i >> 3,
o = Math.ceil((r * i) / 8),
l = new Uint8Array(n * o),
h = 0,
f = [0, 0, 4, 0, 2, 0, 1],
d = [0, 4, 0, 2, 0, 1, 0],
u = [8, 8, 8, 4, 4, 2, 2],
_ = [8, 8, 4, 4, 2, 2, 1],
c = 0;
c < 7;

) {
for (var g = u[c], b = _[c], w = 0, p = 0, v = f[c]; v < n; ) (v += g), p++;
for (var m = d[c]; m < r; ) (m += b), w++;
var k = Math.ceil((w * i) / 8);
t.decode._filterZero(e, a, h, w, p);
for (var y = 0, x = f[c]; x < n; ) {
for (var z = d[c], A = (h + y * k) << 3; z < r; ) {
var B;
if (
(1 == i &&
((B = ((B = e[A >> 3]) >> (7 - (7 & A))) & 1),
(l[x * o + (z >> 3)] |= B << (7 - ((3 & z) << 0)))),
2 == i &&
((B = ((B = e[A >> 3]) >> (6 - (7 & A))) & 3),
(l[x * o + (z >> 2)] |= B << (6 - ((3 & z) << 1)))),
4 == i &&
((B = ((B = e[A >> 3]) >> (4 - (7 & A))) & 15),
(l[x * o + (z >> 1)] |= B << (4 - ((1 & z) << 2)))),
i >= 8)
)
for (var S = x * o + z * s, U = 0; U < s; U++) l[S + U] = e[(A >> 3) + U];
(A += i), (z += b);
}
y++, (x += g);
}
w * p != 0 && (h += p * (1 + k)), (c += 1);
}
return l;
}),
(t.decode._getBPP = function(t) {
return [1, null, 3, 1, 2, null, 4][t.ctype] * t.depth;
}),
(t.decode._filterZero = function(e, a, r, n, i) {
var s = t.decode._getBPP(a),
o = Math.ceil((n * s) / 8),
l = t.decode._paeth;
s = Math.ceil(s / 8);
for (var h = 0; h < i; h++) {
var f = r + h * o,
d = f + h + 1,
u = e[d - 1];
if (0 == u) for (var _ = 0; _ < o; _++) e[f + _] = e[d + _];
else if (1 == u) {
for (_ = 0; _ < s; _++) e[f + _] = e[d + _];
for (_ = s; _ < o; _++) e[f + _] = (e[d + _] + e[f + _ - s]) & 255;
} else if (0 == h) {
for (_ = 0; _ < s; _++) e[f + _] = e[d + _];
if (2 == u) for (_ = s; _ < o; _++) e[f + _] = 255 & e[d + _];
if (3 == u)
for (_ = s; _ < o; _++) e[f + _] = (e[d + _] + (e[f + _ - s] >> 1)) & 255;
if (4 == u)
for (_ = s; _ < o; _++) e[f + _] = (e[d + _] + l(e[f + _ - s], 0, 0)) & 255;
} else {
if (2 == u) for (_ = 0; _ < o; _++) e[f + _] = (e[d + _] + e[f + _ - o]) & 255;
if (3 == u) {
for (_ = 0; _ < s; _++) e[f + _] = (e[d + _] + (e[f + _ - o] >> 1)) & 255;
for (_ = s; _ < o; _++)
e[f + _] = (e[d + _] + ((e[f + _ - o] + e[f + _ - s]) >> 1)) & 255;
}
if (4 == u) {
for (_ = 0; _ < s; _++) e[f + _] = (e[d + _] + l(0, e[f + _ - o], 0)) & 255;
for (_ = s; _ < o; _++)
e[f + _] = (e[d + _] + l(e[f + _ - s], e[f + _ - o], e[f + _ - s - o])) & 255;
}
}
}
return e;
}),
(t.decode._paeth = function(t, e, a) {
var r = t + e - a,
n = Math.abs(r - t),
i = Math.abs(r - e),
s = Math.abs(r - a);
return n <= i && n <= s ? t : i <= s ? e : a;
}),
(t.decode._IHDR = function(e, a, r) {
var n = t._bin;
(r.width = n.readUint(e, a)),
(a += 4),
(r.height = n.readUint(e, a)),
(a += 4),
(r.depth = e[a]),
a++,
(r.ctype = e[a]),
a++,
(r.compress = e[a]),
a++,
(r.filter = e[a]),
a++,
(r.interlace = e[a]),
a++;
}),
(t._bin = {
nextZero: function(t, e) {
for (; 0 != t[e]; ) e++;
return e;
},
readUshort: function(t, e) {
return (t[e] << 8) | t[e + 1];
},
writeUshort: function(t, e, a) {
(t[e] = (a >> 8) & 255), (t[e + 1] = 255 & a);
},
readUint: function(t, e) {
return 16777216 * t[e] + ((t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]);
},
writeUint: function(t, e, a) {
(t[e] = (a >> 24) & 255),
(t[e + 1] = (a >> 16) & 255),
(t[e + 2] = (a >> 8) & 255),
(t[e + 3] = 255 & a);
},
readASCII: function(t, e, a) {
for (var r = "", n = 0; n < a; n++) r += String.fromCharCode(t[e + n]);
return r;
},
writeASCII: function(t, e, a) {
for (var r = 0; r < a.length; r++) t[e + r] = a.charCodeAt(r);
},
readBytes: function(t, e, a) {
for (var r = [], n = 0; n < a; n++) r.push(t[e + n]);
return r;
},
pad: function(t) {
return t.length < 2 ? "0" + t : t;
},
readUTF8: function(e, a, r) {
for (var n, i = "", s = 0; s < r; s++)
i += "%" + t._bin.pad(e[a + s].toString(16));
try {
n = decodeURIComponent(i);
} catch (n) {
return t._bin.readASCII(e, a, r);
}
return n;
}
}),
(t._copyTile = function(t, e, a, r, n, i, s, o, l) {
for (
var h = Math.min(e, n), f = Math.min(a, i), d = 0, u = 0, _ = 0;
_ < f;
_++
)
for (var c = 0; c < h; c++)
if (
(s >= 0 && o >= 0
? ((d = (_ * e + c) << 2), (u = ((o + _) * n + s + c) << 2))
: ((d = ((-o + _) * e - s + c) << 2), (u = (_ * n + c) << 2)),
0 == l)
)
(r[u] = t[d]),
(r[u + 1] = t[d + 1]),
(r[u + 2] = t[d + 2]),
(r[u + 3] = t[d + 3]);
else if (1 == l) {
var g = t[d + 3] * (1 / 255),
b = t[d] * g,
w = t[d + 1] * g,
p = t[d + 2] * g,
v = r[u + 3] * (1 / 255),
m = r[u] * v,
k = r[u + 1] * v,
y = r[u + 2] * v,
x = 1 - g,
z = g + v * x,
A = 0 == z ? 0 : 1 / z;
(r[u + 3] = 255 * z),
(r[u + 0] = (b + m * x) * A),
(r[u + 1] = (w + k * x) * A),
(r[u + 2] = (p + y * x) * A);
} else if (2 == l)
(g = t[d + 3]),
(b = t[d]),
(w = t[d + 1]),
(p = t[d + 2]),
(v = r[u + 3]),
(m = r[u]),
(k = r[u + 1]),
(y = r[u + 2]),
g == v && b == m && w == k && p == y
? ((r[u] = 0), (r[u + 1] = 0), (r[u + 2] = 0), (r[u + 3] = 0))
: ((r[u] = b), (r[u + 1] = w), (r[u + 2] = p), (r[u + 3] = g));
else if (3 == l) {
if (
((g = t[d + 3]),
(b = t[d]),
(w = t[d + 1]),
(p = t[d + 2]),
(v = r[u + 3]),
(m = r[u]),
(k = r[u + 1]),
(y = r[u + 2]),
g == v && b == m && w == k && p == y)
)
continue;
if (g < 220 && v > 20) return !1;
}
return !0;
}),
(t.encode = function(e, a, r, n, i, s) {
null == n && (n = 0), null == s && (s = !1);
for (
var o = new Uint8Array(e[0].byteLength * e.length + 100),
l = [137, 80, 78, 71, 13, 10, 26, 10],
h = 0;
h < 8;
h++
)
o[h] = l[h];
var f = 8,
d = t._bin,
u = t.crc.crc,
_ = d.writeUint,
c = d.writeUshort,
g = d.writeASCII,
b = t.encode.compressPNG(e, a, r, n, s);
_(o, f, 13),
g(o, (f += 4), "IHDR"),
_(o, (f += 4), a),
_(o, (f += 4), r),
(o[(f += 4)] = b.depth),
(o[++f] = b.ctype),
(o[++f] = 0),
(o[++f] = 0),
(o[++f] = 0),
_(o, ++f, u(o, f - 17, 17)),
_(o, (f += 4), 1),
g(o, (f += 4), "sRGB"),
(o[(f += 4)] = 1),
_(o, ++f, u(o, f - 5, 5)),
(f += 4);
var w = e.length > 1;
if (
(w &&
(_(o, f, 8),
g(o, (f += 4), "acTL"),
_(o, (f += 4), e.length),
_(o, (f += 4), 0),
_(o, (f += 4), u(o, f - 12, 12)),
(f += 4)),
3 == b.ctype)
) {
for (
_(o, f, 3 * (B = b.plte.length)), g(o, (f += 4), "PLTE"), f += 4, h = 0;
h < B;
h++
) {
var p = 3 * h,
v = b.plte[h],
m = 255 & v,
k = (v >> 8) & 255,
y = (v >> 16) & 255;
(o[f + p + 0] = m), (o[f + p + 1] = k), (o[f + p + 2] = y);
}
if (
(_(o, (f += 3 * B), u(o, f - 3 * B - 4, 3 * B + 4)), (f += 4), b.gotAlpha)
) {
for (_(o, f, B), g(o, (f += 4), "tRNS"), f += 4, h = 0; h < B; h++)
o[f + h] = (b.plte[h] >> 24) & 255;
_(o, (f += B), u(o, f - B - 4, B + 4)), (f += 4);
}
}
for (var x = 0, z = 0; z < b.frames.length; z++) {
var A = b.frames[z];
w &&
(_(o, f, 26),
g(o, (f += 4), "fcTL"),
_(o, (f += 4), x++),
_(o, (f += 4), A.rect.width),
_(o, (f += 4), A.rect.height),
_(o, (f += 4), A.rect.x),
_(o, (f += 4), A.rect.y),
c(o, (f += 4), i[z]),
c(o, (f += 2), 1e3),
(o[(f += 2)] = A.dispose),
(o[++f] = A.blend),
_(o, ++f, u(o, f - 30, 30)),
(f += 4));
var B,
S = A.cimg;
_(o, f, (B = S.length) + (0 == z ? 0 : 4));
var U = (f += 4);
for (
g(o, f, 0 == z ? "IDAT" : "fdAT"),
f += 4,
0 != z && (_(o, f, x++), (f += 4)),
h = 0;
h < B;
h++
)
o[f + h] = S[h];
_(o, (f += B), u(o, U, f - U)), (f += 4);
}
return (
_(o, f, 0),
g(o, (f += 4), "IEND"),
_(o, (f += 4), u(o, f - 4, 4)),
(f += 4),
o.buffer.slice(0, f)
);
}),
(t.encode.compressPNG = function(e, a, r, n, i) {
for (var s = t.encode.compress(e, a, r, n, !1, i), o = 0; o < e.length; o++) {
var l = s.frames[o],
h = (l.rect.width, l.rect.height),
f = l.bpl,
d = l.bpp,
u = new Uint8Array(h * f + h);
l.cimg = t.encode._filterZero(l.img, h, d, f, u);
}
return s;
}),
(t.encode.compress = function(e, a, r, n, i, s) {
null == s && (s = !1);
for (var o = 6, l = 8, h = 4, f = 255, d = 0; d < e.length; d++)
for (var u = new Uint8Array(e[d]), _ = u.length, c = 0; c < _; c += 4)
f &= u[c + 3];
var g = 255 != f,
b = {},
w = [];
if ((0 != e.length && ((b[0] = 0), w.push(0), 0 != n && n--), 0 != n)) {
var p = t.quantize(e, n, i);
for (e = p.bufs, c = 0; c < p.plte.length; c++)
null == b[(m = p.plte[c].est.rgba)] && ((b[m] = w.length), w.push(m));
} else
for (d = 0; d < e.length; d++) {
var v = new Uint32Array(e[d]);
for (_ = v.length, c = 0; c < _; c++) {
var m = v[c];
if (
(c < a || (m != v[c - 1] && m != v[c - a])) &&
null == b[m] &&
((b[m] = w.length), w.push(m), w.length >= 300)
)
break;
}
}
var k = !!g && i,
y = w.length;
y <= 256 &&
0 == s &&
((l = y <= 2 ? 1 : y <= 4 ? 2 : y <= 16 ? 4 : 8), i && (l = 8), (g = !0));
var x = [];
for (d = 0; d < e.length; d++) {
var z = new Uint8Array(e[d]),
A = new Uint32Array(z.buffer),
B = 0,
S = 0,
U = a,
E = r,
R = 0;
if (0 != d && !k) {
for (
var I = i || 1 == d || 2 == x[x.length - 2].dispose ? 1 : 2,
Z = 0,
T = 1e9,
N = 0;
N < I;
N++
) {
for (
var C = new Uint8Array(e[d - 1 - N]),
D = new Uint32Array(e[d - 1 - N]),
M = a,
L = r,
O = -1,
q = -1,
F = 0;
F < r;
F++
)
for (var H = 0; H < a; H++)
A[(c = F * a + H)] != D[c] &&
(H < M && (M = H), H > O && (O = H), F < L && (L = F), F > q && (q = F));
var P = -1 == O ? 1 : (O - M + 1) * (q - L + 1);
P < T &&
((T = P),
(Z = N),
-1 == O
? ((B = S = 0), (U = E = 1))
: ((B = M), (S = L), (U = O - M + 1), (E = q - L + 1)));
}
(C = new Uint8Array(e[d - 1 - Z])), 1 == Z && (x[x.length - 1].dispose = 2);
var j = new Uint8Array(U * E * 4);
new Uint32Array(j.buffer),
t._copyTile(C, a, r, j, U, E, -B, -S, 0),
t._copyTile(z, a, r, j, U, E, -B, -S, 3)
? (t._copyTile(z, a, r, j, U, E, -B, -S, 2), (R = 1))
: (t._copyTile(z, a, r, j, U, E, -B, -S, 0), (R = 0)),
(z = j),
(A = new Uint32Array(z.buffer));
}
var G = 4 * U;
if (y <= 256 && 0 == s) {
for (G = Math.ceil((l * U) / 8), j = new Uint8Array(G * E), F = 0; F < E; F++) {
c = F * G;
var K = F * U;
if (8 == l) for (H = 0; H < U; H++) j[c + H] = b[A[K + H]];
else if (4 == l)
for (H = 0; H < U; H++) j[c + (H >> 1)] |= b[A[K + H]] << (4 - 4 * (1 & H));
else if (2 == l)
for (H = 0; H < U; H++) j[c + (H >> 2)] |= b[A[K + H]] << (6 - 2 * (3 & H));
else if (1 == l)
for (H = 0; H < U; H++) j[c + (H >> 3)] |= b[A[K + H]] << (7 - 1 * (7 & H));
}
(z = j), (o = 3), (h = 1);
} else if (0 == g && 1 == e.length) {
j = new Uint8Array(U * E * 3);
var Y = U * E;
for (c = 0; c < Y; c++) {
var X = 3 * c,
V = 4 * c;
(j[X] = z[V]), (j[X + 1] = z[V + 1]), (j[X + 2] = z[V + 2]);
}
(z = j), (o = 2), (h = 3), (G = 3 * U);
}
x.push({
rect: {x: B, y: S, width: U, height: E},
img: z,
bpl: G,
bpp: h,
blend: R,
dispose: k ? 1 : 0
});
}
return {ctype: o, depth: l, plte: w, gotAlpha: g, frames: x};
}),
(t.encode._filterZero = function(a, r, n, i, s) {
for (var o = [], l = 0; l < 5; l++)
if (!(r * i > 5e5) || (2 != l && 3 != l && 4 != l)) {
for (var h = 0; h < r; h++) t.encode._filterLine(s, a, h, i, n, l);
if ((o.push(e.deflate(s)), 1 == n)) break;
}
for (var f, d = 1e9, u = 0; u < o.length; u++)
o[u].length < d && ((f = u), (d = o[u].length));
return o[f];
}),
(t.encode._filterLine = function(e, a, r, n, i, s) {
var o = r * n,
l = o + r,
h = t.decode._paeth;
if (((e[l] = s), l++, 0 == s)) for (var f = 0; f < n; f++) e[l + f] = a[o + f];
else if (1 == s) {
for (f = 0; f < i; f++) e[l + f] = a[o + f];
for (f = i; f < n; f++) e[l + f] = (a[o + f] - a[o + f - i] + 256) & 255;
} else if (0 == r) {
for (f = 0; f < i; f++) e[l + f] = a[o + f];
if (2 == s) for (f = i; f < n; f++) e[l + f] = a[o + f];
if (3 == s)
for (f = i; f < n; f++) e[l + f] = (a[o + f] - (a[o + f - i] >> 1) + 256) & 255;
if (4 == s)
for (f = i; f < n; f++)
e[l + f] = (a[o + f] - h(a[o + f - i], 0, 0) + 256) & 255;
} else {
if (2 == s)
for (f = 0; f < n; f++) e[l + f] = (a[o + f] + 256 - a[o + f - n]) & 255;
if (3 == s) {
for (f = 0; f < i; f++) e[l + f] = (a[o + f] + 256 - (a[o + f - n] >> 1)) & 255;
for (f = i; f < n; f++)
e[l + f] = (a[o + f] + 256 - ((a[o + f - n] + a[o + f - i]) >> 1)) & 255;
}
if (4 == s) {
for (f = 0; f < i; f++)
e[l + f] = (a[o + f] + 256 - h(0, a[o + f - n], 0)) & 255;
for (f = i; f < n; f++)
e[l + f] =
(a[o + f] + 256 - h(a[o + f - i], a[o + f - n], a[o + f - i - n])) & 255;
}
}
}),
(t.crc = {
table: (function() {
for (var t = new Uint32Array(256), e = 0; e < 256; e++) {
for (var a = e, r = 0; r < 8; r++)
1 & a ? (a = 3988292384 ^ (a >>> 1)) : (a >>>= 1);
t[e] = a;
}
return t;
})(),
update: function(e, a, r, n) {
for (var i = 0; i < n; i++) e = t.crc.table[255 & (e ^ a[r + i])] ^ (e >>> 8);
return e;
},
crc: function(e, a, r) {
return 4294967295 ^ t.crc.update(4294967295, e, a, r);
}
}),
(t.quantize = function(e, a, r) {
for (var n = [], i = 0, s = 0; s < e.length; s++)
n.push(t.encode.alphaMul(new Uint8Array(e[s]), r)), (i += e[s].byteLength);
var o = new Uint8Array(i),
l = new Uint32Array(o.buffer),
h = 0;
for (s = 0; s < n.length; s++) {
for (var f = n[s], d = f.length, u = 0; u < d; u++) o[h + u] = f[u];
h += d;
}
var _ = {
i0: 0,
i1: o.length,
bst: null,
est: null,
tdst: 0,
left: null,
right: null
};
(_.bst = t.quantize.stats(o, _.i0, _.i1)), (_.est = t.quantize.estats(_.bst));
for (var c = [_]; c.length < a; ) {
var g = 0,
b = 0;
for (s = 0; s < c.length; s++) c[s].est.L > g && ((g = c[s].est.L), (b = s));
if (g < 0.001) break;
var w = c[b],
p = t.quantize.splitPixels(o, l, w.i0, w.i1, w.est.e, w.est.eMq255),
v = {i0: w.i0, i1: p, bst: null, est: null, tdst: 0, left: null, right: null};
(v.bst = t.quantize.stats(o, v.i0, v.i1)), (v.est = t.quantize.estats(v.bst));
var m = {
i0: p,
i1: w.i1,
bst: null,
est: null,
tdst: 0,
left: null,
right: null
};
for (m.bst = {R: [], m: [], N: w.bst.N - v.bst.N}, s = 0; s < 16; s++)
m.bst.R[s] = w.bst.R[s] - v.bst.R[s];
for (s = 0; s < 4; s++) m.bst.m[s] = w.bst.m[s] - v.bst.m[s];
(m.est = t.quantize.estats(m.bst)),
(w.left = v),
(w.right = m),
(c[b] = v),
c.push(m);
}
c.sort(function(t, e) {
return e.bst.N - t.bst.N;
});
for (var k = 0; k < n.length; k++) {
var y = t.quantize.planeDst,
x = new Uint8Array(n[k].buffer),
z = new Uint32Array(n[k].buffer),
A = x.length;
for (s = 0; s < A; s += 4) {
for (
var B = x[s] * (1 / 255),
S = x[s + 1] * (1 / 255),
U = x[s + 2] * (1 / 255),
E = x[s + 3] * (1 / 255),
R = _;
R.left;

)
R = y(R.est, B, S, U, E) <= 0 ? R.left : R.right;
z[s >> 2] = R.est.rgba;
}
n[k] = z.buffer;
}
return {bufs: n, plte: c};
}),
(t.quantize.getNearest = function(e, a, r, n, i) {
if (null == e.left) return (e.tdst = t.quantize.dist(e.est.q, a, r, n, i)), e;
var s = t.quantize.planeDst(e.est, a, r, n, i),
o = e.left,
l = e.right;
s > 0 && ((o = e.right), (l = e.left));
var h = t.quantize.getNearest(o, a, r, n, i);
if (h.tdst <= s * s) return h;
var f = t.quantize.getNearest(l, a, r, n, i);
return f.tdst < h.tdst ? f : h;
}),
(t.quantize.planeDst = function(t, e, a, r, n) {
var i = t.e;
return i[0] * e + i[1] * a + i[2] * r + i[3] * n - t.eMq;
}),
(t.quantize.dist = function(t, e, a, r, n) {
var i = e - t[0],
s = a - t[1],
o = r - t[2],
l = n - t[3];
return i * i + s * s + o * o + l * l;
}),
(t.quantize.splitPixels = function(e, a, r, n, i, s) {
var o = t.quantize.vecDot;
for (n -= 4; r < n; ) {
for (; o(e, r, i) <= s; ) r += 4;
for (; o(e, n, i) > s; ) n -= 4;
if (r >= n) break;
var l = a[r >> 2];
(a[r >> 2] = a[n >> 2]), (a[n >> 2] = l), (r += 4), (n -= 4);
}
for (; o(e, r, i) > s; ) r -= 4;
return r + 4;
}),
(t.quantize.vecDot = function(t, e, a) {
return t[e] * a[0] + t[e + 1] * a[1] + t[e + 2] * a[2] + t[e + 3] * a[3];
}),
(t.quantize.stats = function(t, e, a) {
for (
var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
n = [0, 0, 0, 0],
i = (a - e) >> 2,
s = e;
s < a;
s += 4
) {
var o = t[s] * (1 / 255),
l = t[s + 1] * (1 / 255),
h = t[s + 2] * (1 / 255),
f = t[s + 3] * (1 / 255);
(n[0] += o),
(n[1] += l),
(n[2] += h),
(n[3] += f),
(r[0] += o * o),
(r[1] += o * l),
(r[2] += o * h),
(r[3] += o * f),
(r[5] += l * l),
(r[6] += l * h),
(r[7] += l * f),
(r[10] += h * h),
(r[11] += h * f),
(r[15] += f * f);
}
return (
(r[4] = r[1]),
(r[8] = r[2]),
(r[12] = r[3]),
(r[9] = r[6]),
(r[13] = r[7]),
(r[14] = r[11]),
{R: r, m: n, N: i}
);
}),
(t.quantize.estats = function(e) {
var a = e.R,
r = e.m,
n = e.N,
i = r[0],
s = r[1],
o = r[2],
l = r[3],
h = 0 == n ? 0 : 1 / n,
f = [
a[0] - i * i * h,
a[1] - i * s * h,
a[2] - i * o * h,
a[3] - i * l * h,
a[4] - s * i * h,
a[5] - s * s * h,
a[6] - s * o * h,
a[7] - s * l * h,
a[8] - o * i * h,
a[9] - o * s * h,
a[10] - o * o * h,
a[11] - o * l * h,
a[12] - l * i * h,
a[13] - l * s * h,
a[14] - l * o * h,
a[15] - l * l * h
],
d = f,
u = t.M4,
_ = [0.5, 0.5, 0.5, 0.5],
c = 0,
g = 0;
if (0 != n)
for (
var b = 0;
b < 10 &&
((_ = u.multVec(d, _)),
(g = Math.sqrt(u.dot(_, _))),
(_ = u.sml(1 / g, _)),
!(Math.abs(g - c) < 1e-9));
b++
)
c = g;
var w = [i * h, s * h, o * h, l * h],
p = u.dot(u.sml(255, w), _),
v = w[3] < 0.001 ? 0 : 1 / w[3];
return {
Cov: f,
q: w,
e: _,
L: c,
eMq255: p,
eMq: u.dot(_, w),
rgba:
((Math.round(255 * w[3]) << 24) |
(Math.round(255 * w[2] * v) << 16) |
(Math.round(255 * w[1] * v) << 8) |
(Math.round(255 * w[0] * v) << 0)) >>>
0
};
}),
(t.M4 = {
multVec: function(t, e) {
return [
t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3],
t[4] * e[0] + t[5] * e[1] + t[6] * e[2] + t[7] * e[3],
t[8] * e[0] + t[9] * e[1] + t[10] * e[2] + t[11] * e[3],
t[12] * e[0] + t[13] * e[1] + t[14] * e[2] + t[15] * e[3]
];
},
dot: function(t, e) {
return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
},
sml: function(t, e) {
return [t * e[0], t * e[1], t * e[2], t * e[3]];
}
}),
(t.encode.alphaMul = function(t, e) {
for (var a = new Uint8Array(t.length), r = t.length >> 2, n = 0; n < r; n++) {
var i = n << 2,
s = t[i + 3];
e && (s = s < 128 ? 0 : 255);
var o = s * (1 / 255);
(a[i + 0] = t[i + 0] * o),
(a[i + 1] = t[i + 1] * o),
(a[i + 2] = t[i + 2] * o),
(a[i + 3] = s);
}
return a;
});
})(e, Ya);
}),
Va = {
downloadAsImage: function(t, e, a) {
let r = e.width,
n = e.height,
i = new Uint8Array(r * n * 4);
t.readRenderTargetPixels(e, 0, 0, r, n, i),
(function(t, e, a) {
let r = document.createElement("a");
if (void 0 === window)
throw "following download won't work, for some reason window is not defined.";
let n = new Blob([t], {type: "application/octet-stream"});
if (
((r.href = window.URL.createObjectURL(n)),
(r.download = e + "." + a),
document.createEvent)
) {
let t = document.createEvent("MouseEvents");
t.initEvent("click", !0, !0), r.dispatchEvent(t);
} else r.click();
})(
(function(t, e, a) {
return Xa.encode([t.buffer], e, a, 0);
})(
(function(t, e, a) {
for (var r = new Uint8Array(e * a * 4), n = 0; n < e; ++n)
for (var i = 0; i < a; ++i) {
var s = 4 * (n + i * e),
o = 4 * (n + (a - i - 1) * e);
(r[s] = t[o]),
(r[s + 1] = t[o + 1]),
(r[s + 2] = t[o + 2]),
(r[s + 3] = t[o + 3]);
}
return r;
})(i, r, n),
r,
n
),
a,
"png"
);
}
};
return (t.DebugRenderTarget = Va), Va;
});
